// ================================================================================================
///////////////////////////////////////////////////////////////////////////////////////////////////
//// HISTORY //////////////////////////////////////////////////////////////////////////////////////
// ================================================================================================
//  Authors: Wall
//      File: Wallcraft M2 Workshop.1sc
//  Version: 1.0.12
//  Purpose: Resizes M2 Models
//  Category: M2 Editing
//  History: This script allows detailed modifying of Blizzard M2 files, including resizing and rescaling.
//      1.0.12 2025-04-21 Wall: Add additional debug
//      1.0.11 2025-04-20 Wall: Add remaining particle tracks
//      1.0.10 2025-04-19 Wall: Add remaining ribbon tracks
//      1.0.9  2025-04-18 Wall: Add subtracks to all blocks
//      1.0.8  2025-04-17 Wall: Add color, weight, transform
//      1.0.7  2025-04-16 Wall: Add events, lights, ribbons
//      1.0.6  2025-04-15 Wall: Add loading of .anim files
//      1.0.5  2025-04-14 Wall: Add expansion support
//      1.0.4  2025-04-13 Wall: Add configs for each block
//      1.0.3  2025-04-12 Wall: Add animation scaling
//      1.0.2  2025-04-11 Wall: Add scaling tracks
//      1.0.1  2025-04-10 Wall: Add quaternion support
//      1.0.0  2025-04-09 Wall: Add initial framework
// ================================================================================================
///////////////////////////////////////////////////////////////////////////////////////////////////
//// INFO /////////////////////////////////////////////////////////////////////////////////////////
// ==== INSTRUCTIONS ==============================================================================
// - This script allows for the modifying of M2 files. It can fully adjust scaling, including 
// animation scaling. This script does not require templating, and can be run on multiple files.
// 
// - You can enable & adjust the VARIABLES sections below to modify various scaling factors
// of your M2 file. This includes bones, sequences, vertices, attachments, cameras, particles.
//
// - If you simply wish to scale the overall model, then ENABLE [basicScaling] in the PARAMETERS
// section and use the [basicScalingModifier] options. This will override all other modifiers.  
// 
// - If you wish to modify specific aspects of the model, then DISABLE [basicScaling] and ENABLE
// the specific PARAMETERS along with the related modifiers.
//
// - TIP: Running an M2 template on your file before running the script will SIGNIFICANTLY
// decrease performance. Run the script on the raw file first before running your template.
// 
// - TIP: Using the [debug] option will cause 010 to hang while it parses all the chunks.
// Wait until the script is finished running. It will not crash.
//
// - TIP: Using the [autoClose] option when running WotLK+ M2 files that have .anim files will
// cause them to be closed each time they are written to. This will decrease performance.
// ================================================================================================
///////////////////////////////////////////////////////////////////////////////////////////////////
//// CONFIGURATION ////////////////////////////////////////////////////////////////////////////////
// ==== GENERAL ===================================================================================
int readOnly    = 0; // Enable to only read data        // Enable(1)/Disable(0) ------ Default: 0 -
int autoSave    = 0; // Enable to auto save file        // Enable(1)/Disable(0) ------ Default: 0 -
int autoClose   = 0; // Enable to auto close file       // Enable(1)/Disable(0) ------ Default: 0 -
int silent      = 0; // Enable to minimize output       // Enable(1)/Disable(0) ------ Default: 0 -
int debug       = 0; // Enable to allow debug output    // Enable(1)/Disable(0) ------ Default: 0 -
int testRun     = 0; // Enable to only run one block    // Enable(1)/Disable(0) ------ Default: 0 -
// ==== PARAMETERS ================================================================================
int basicScaling        = 1; // Overrides all modifiers // Enable(1)/Disable(0) ------ Default: 1 -
int sequenceEnabled     = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int boneEnabled         = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int verticeEnabled      = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int colorEnabled        = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int weightEnabled       = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int transformEnabled    = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int boundingEnabled     = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int collisionEnabled    = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int normalEnabled       = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int attachmentEnabled   = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int eventEnabled        = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int lightEnabled        = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int cameraEnabled       = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int ribbonEnabled       = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
int particleEnabled     = 1;                            // Enable(1)/Disable(0) ------ Default: 1 -
// ==== MODIFIERS: BASIC SCALING ==================================================================
float basicModifierX                           = 1.00f; // Basic Scaling Float ---- Default: 1.00 -
float basicModifierY                           = 1.00f; // Basic Scaling Float ---- Default: 1.00 -
float basicModifierZ                           = 1.00f; // Basic Scaling Float ---- Default: 1.00 -
float basicModifierR                           = 1.00f; // Basic Scaling Float ---- Default: 1.00 -
// ==== MODIFIERS: SEQUENCE =======================================================================
float sequencePositionX                        = 1.00f; // Sequence X Float ------- Default: 1.00 -
float sequencePositionY                        = 1.00f; // Sequence Y Float ------- Default: 1.00 -
float sequencePositionZ                        = 1.00f; // Sequence Z Float ------- Default: 1.00 -
float sequencePositionR                        = 1.00f; // Sequence R Float ------- Default: 1.00 -
// ==== MODIFIERS: BONE ===========================================================================
float boneTranslationPositionX                 = 1.00f; // Translation X Float ---- Default: 1.00 -
float boneTranslationPositionY                 = 1.00f; // Translation Y Float ---- Default: 1.00 -
float boneTranslationPositionZ                 = 1.00f; // Translation Z Float ---- Default: 1.00 -
float boneRotationPositionX                    = 1.00f; // Rotation X Float-Short - Default: 1.00 -
float boneRotationPositionY                    = 1.00f; // Rotation Y Float-Short - Default: 1.00 -
float boneRotationPositionZ                    = 1.00f; // Rotation Z Float-Short - Default: 1.00 -
float boneRotationPositionW                    = 1.00f; // Rotation W Float-Short - Default: 1.00 -
float boneScalePositionX                       = 1.00f; // Scale X Float ---------- Default: 1.00 -
float boneScalePositionY                       = 1.00f; // Scale Y Float ---------- Default: 1.00 -
float boneScalePositionZ                       = 1.00f; // Scale Z Float ---------- Default: 1.00 -
float bonePivotPositionX                       = 1.00f; // Bone Pivot X Float ----- Default: 1.00 -
float bonePivotPositionY                       = 1.00f; // Bone Pivot Y Float ----- Default: 1.00 -
float bonePivotPositionZ                       = 1.00f; // Bone Pivot Z Float ----- Default: 1.00 -
// ==== MODIFIERS: VERTICE ========================================================================
float verticePositionX                         = 1.00f; // Vertice X Float -------- Default: 1.00 -
float verticePositionY                         = 1.00f; // Vertice Y Float -------- Default: 1.00 -
float verticePositionZ                         = 1.00f; // Vertice Z Float -------- Default: 1.00 -
// ==== MODIFIERS: COLOR ==========================================================================
float colorModifierR                           = 1.00f; // Color R Float Range ---- 0.00f - 1.00f -
float colorModifierG                           = 1.00f; // Color G Float Range ---- 0.00f - 1.00f -
float colorModifierB                           = 1.00f; // Color B Float Range ---- 0.00f - 1.00f -
int colorModifierA                             = 1;     // Color A Int ---- 0.00f - 1.00f -
// ==== MODIFIERS: WEIGHT =========================================================================
int weightModifierA                            = 1;     // Texture Weights A Int -- Default: 1.00 -
// ==== MODIFIERS: TRANSFORM ======================================================================
float transformTranslationPositionX            = 1.00f; // Texture Translation X -- Default: 1.00 -
float transformTranslationPositionY            = 1.00f; // Texture Translation Y -- Default: 1.00 -
float transformTranslationPositionZ            = 1.00f; // Texture Translation Z -- Default: 1.00 -
float transformRotationPositionX               = 1.00f; // Texture Rotation X ----- Default: 1.00 -
float transformRotationPositionY               = 1.00f; // Texture Rotation Y ----- Default: 1.00 -
float transformRotationPositionZ               = 1.00f; // Texture Rotation Z ----- Default: 1.00 -
float transformRotationPositionW               = 1.00f; // Texture Rotation W ----- Default: 1.00 -
float transformScalePositionX                  = 1.00f; // Texture Scaling X ------ Default: 1.00 -
float transformScalePositionY                  = 1.00f; // Texture Scaling Y ------ Default: 1.00 -
float transformScalePositionZ                  = 1.00f; // Texture Scaling Z ------ Default: 1.00 -
// ==== MODIFIERS: BOUNDING =======================================================================
float boundingPositionX                        = 1.00f; // Bounding X Float ------- Default: 1.00 -
float boundingPositionY                        = 1.00f; // Bounding Y Float ------- Default: 1.00 -
float boundingPositionZ                        = 1.00f; // Bounding Z Float ------- Default: 1.00 -
float boundingPositionR                        = 1.00f; // Bounding R Float ------- Default: 1.00 -
// ==== MODIFIERS: COLLISION ======================================================================
float collisionPositionX                       = 1.00f; // Collision X Float ------ Default: 1.00 -
float collisionPositionY                       = 1.00f; // Collision Y Float ------ Default: 1.00 -
float collisionPositionZ                       = 1.00f; // Collision Z Float ------ Default: 1.00 -
float collisionPositionR                       = 1.00f; // Collision R Float ------ Default: 1.00 -
// ==== MODIFIERS: NORMAL =========================================================================
float normalPositionX                          = 1.00f; // Normal Position X ------ Default: 1.00 -
float normalPositionY                          = 1.00f; // Normal Position Y ------ Default: 1.00 -
float normalPositionZ                          = 1.00f; // Normal Position Z ------ Default: 1.00 -
// ==== MODIFIERS: ATTACHMENT =====================================================================
float attachmentPositionX                      = 1.00f; // Attachment Position X -- Default: 1.00 -
float attachmentPositionY                      = 1.00f; // Attachment Position Y -- Default: 1.00 -
float attachmentPositionZ                      = 1.00f; // Attachment Position Z -- Default: 1.00 -
// ==== MODIFIERS: EVENT ==========================================================================
float eventPositionX                           = 1.00f; // Attachment X Float ----- Default: 1.00 -
float eventPositionY                           = 1.00f; // Attachment Y Float ----- Default: 1.00 -
float eventPositionZ                           = 1.00f; // Attachment Z Float ----- Default: 1.00 -
// ==== MODIFIERS: LIGHT ==========================================================================
float lightPositionX                           = 1.00f; // Attachment X Float ----- Default: 1.00 -
float lightPositionY                           = 1.00f; // Attachment Y Float ----- Default: 1.00 -
float lightPositionZ                           = 1.00f; // Attachment Z Float ----- Default: 1.00 -
float lightAmbientR                            = 1.00f; // Light Ambient R Range -- 0.00f - 1.00f -
float lightAmbientG                            = 1.00f; // Light Ambient G Range -- 0.00f - 1.00f -
float lightAmbientB                            = 1.00f; // Light Ambient B Range -- 0.00f - 1.00f -
float lightIntensity                           = 1.00f; // Light Intensity Range -- 0.00f - 1.00f -
float lightDiffuseR                            = 1.00f; // Light Diffuse R Range -- 0.00f - 1.00f -
float lightDiffuseG                            = 1.00f; // Light Diffuse G Range -- 0.00f - 1.00f -
float lightDiffuseB                            = 1.00f; // Light Diffuse B Range -- 0.00f - 1.00f -
float lightAttenuationStart                    = 1.00f; // Light Atten. Start ---- Default: 1.00f -
float lightAttenuationEnd                      = 1.00f; // Light Atten. End ------ Default: 1.00f -
ubyte lightVisibility                          = 1;     // Light Visibility ---------- Default: 1 - 
// ==== MODIFIERS: CAMERA =========================================================================
float cameraFov                                = 1.00f; // Camera FOV ------------- Default: 1.00 -
float cameraFarclip                            = 1.00f; // Camera Far Clip -------- Default: 1.00 -
float cameraNearclip                           = 1.00f; // Camera Near Clip ------- Default: 1.00 -
float cameraTranslationPosPointX               = 1.00f; // TranslationPosPointX --- Default: 1.00 -
float cameraTranslationPosTanInX               = 1.00f; // TranslationPosTanInX --- Default: 1.00 -
float cameraTranslationPosTanOutX              = 1.00f; // TranslationPosTanOutX -- Default: 1.00 -
float cameraTranslationPosPointY               = 1.00f; // TranslationPosPointY --- Default: 1.00 -
float cameraTranslationPosTanInY               = 1.00f; // TranslationPosTanInY --- Default: 1.00 -
float cameraTranslationPosTanOutY              = 1.00f; // TranslationPosTanOutY -- Default: 1.00 -
float cameraTranslationPosPointZ               = 1.00f; // TranslationPosPointY --- Default: 1.00 -
float cameraTranslationPosTanInZ               = 1.00f; // TranslationPosTanInY --- Default: 1.00 -
float cameraTranslationPosTanOutZ              = 1.00f; // TranslationPosTanOutY -- Default: 1.00 -
float cameraPositionX                          = 1.00f; // Camera Position X ------ Default: 1.00 -
float cameraPositionY                          = 1.00f; // Camera Position Y ------ Default: 1.00 -
float cameraPositionZ                          = 1.00f; // Camera Position Z ------ Default: 1.00 -
float cameraTranslationTarPointX               = 1.00f; // TranslationTarPointX --- Default: 1.00 -
float cameraTranslationTarTanInX               = 1.00f; // TranslationTarTanInX --- Default: 1.00 -
float cameraTranslationTarTanOutX              = 1.00f; // TranslationTarTanOutX -- Default: 1.00 -
float cameraTranslationTarPointY               = 1.00f; // TranslationTarPointY --- Default: 1.00 -
float cameraTranslationTarTanInY               = 1.00f; // TranslationTarTanInY --- Default: 1.00 -
float cameraTranslationTarTanOutY              = 1.00f; // TranslationTarTanOutY -- Default: 1.00 -
float cameraTranslationTarPointZ               = 1.00f; // TranslationTarPointZ --- Default: 1.00 -
float cameraTranslationTarTanInZ               = 1.00f; // TranslationTarTanInZ --- Default: 1.00 -
float cameraTranslationTarTanOutZ              = 1.00f; // TranslationTarTanOutZ -- Default: 1.00 -
float cameraTargetX                            = 1.00f; // Camera Target X -------- Default: 1.00 -
float cameraTargetY                            = 1.00f; // Camera Target Y -------- Default: 1.00 -
float cameraTargetZ                            = 1.00f; // Camera Target Z -------- Default: 1.00 -
float cameraRollX                              = 1.00f; // Camera Roll X ---------- Default: 1.00 -
float cameraRollY                              = 1.00f; // Camera Roll Y ---------- Default: 1.00 -
float cameraRollZ                              = 1.00f; // Camera Roll Z ---------- Default: 1.00 -
// ==== MODIFIERS: RIBBON =========================================================================
float ribbonPositionX                          = 1.00f; // Ribbon X Float --------- Default: 1.00 -
float ribbonPositionY                          = 1.00f; // Ribbon Y Float --------- Default: 1.00 -
float ribbonPositionZ                          = 1.00f; // Ribbon Z Float --------- Default: 1.00 -
float ribbonColorR                             = 1.00f; // Ribbon Color R Range --- 0.00f - 1.00f -
float ribbonColorG                             = 1.00f; // Ribbon Color G Range --- 0.00f - 1.00f -
float ribbonColorB                             = 1.00f; // Ribbon Color B Range --- 0.00f - 1.00f -
int ribbonAlpha                                = 1;     // Ribbon Alpha ----------- 0.00f - 1.00f -
float ribbonHeightAbove                        = 1.00f; // Ribbon Height Above ---- Default: 1.00 -
float ribbonHeightBelow                        = 1.00f; // Ribbon Height Below ---- Default: 1.00 -
float ribbonEdgeRate                           = 1.00f; // Ribbon Edge Rate ------- Default: 1.00 -
float ribbonEdgeLifespan                       = 1.00f; // Ribbon Edge Lifespan --- Default: 1.00 -
float ribbonGravity                            = 1.00f; // Ribbon Gravity --------- Default: 1.00 -
byte ribbonVisibility                          = 1;     // Ribbon Visibility --------- Default: 1 -
// ==== MODIFIERS: PARTICLE =======================================================================
float particlePositionX                        = 1.00f; // Particle X Float ------- Default: 1.00 -
float particlePositionY                        = 1.00f; // Particle Y Float ------- Default: 1.00 -
float particlePositionZ                        = 1.00f; // Particle Z Float ------- Default: 1.00 -
float particleEmissionSpeed                    = 1.00f; // Particle Emission ------ Default: 1.00 -
float particleSpeed                            = 1.00f; // Particle Speed --------- Default: 1.00 -
float particleVertical                         = 1.00f; // Particle Vertical ------ Default: 1.00 -
float particleHorizontal                       = 1.00f; // Particle Horizontal ---- Default: 1.00 -
float particleGravity                          = 1.00f; // Particle Gravity ------- Default: 1.00 -
float particleLifespan                         = 1.00f; // Particle Lifespan ------ Default: 1.00 -
float particleLifespanVary                     = 1.00f; // Particle Lifespan Vary - Default: 1.00 -
float particleEmissionRate                     = 1.00f; // Particle Rate ---------- Default: 1.00 -
float particleEmissionRateVary                 = 1.00f; // Particle Rate Vary ----- Default: 1.00 -
float particleEmissionLength                   = 1.00f; // Particle Emission L ---- Default: 1.00 -
float particleEmissionWidth                    = 1.00f; // Particle Emission W ---- Default: 1.00 -
float particleSourceZ                          = 1.00f; // Particle Source Z ------ Default: 1.00 -
float particleMidpoint                         = 1.00f; // Particle Midpoint ------ Default: 1.00 -
float particleColorByteR                       = 1.00f; // Particle Color R Range --- 0.00 - 1.00 -
float particleColorByteG                       = 1.00f; // Particle Color G Range --- 0.00 - 1.00 -
float particleColorByteB                       = 1.00f; // Particle Color B Range --- 0.00 - 1.00 -
float particleColorByteA                       = 1.00f; // Particle Color A Range --- 0.00 - 1.00 -
float particleColorFloatR                      = 1.00f; // Particle Color R Range --- 0.00 - 1.00 -
float particleColorFloatG                      = 1.00f; // Particle Color G Range --- 0.00 - 1.00 -
float particleColorFloatB                      = 1.00f; // Particle Color B Range --- 0.00 - 1.00 -
float particleColorFloatA                      = 1.00f; // Particle Color A Range --- 0.00 - 1.00 -
float particleScaleX                           = 1.00f; // Particle Scale X ------- Default: 1.00 -
float particleScaleY                           = 1.00f; // Particle Scale Y ------- Default: 1.00 -
float particleScaleVaryX                       = 1.00f; // Particle Scale Vary X -- Default: 1.00 -
float particleScaleVaryY                       = 1.00f; // Particle Scale Vary Y -- Default: 1.00 -
float particleTailLength                       = 1.00f; // Particle Tail Length --- Default: 1.00 -
float particleTwinkleSpeed                     = 1.00f; // Particle Twinkle Speed - Default: 1.00 -
float particleTwinklePercent                   = 1.00f; // Particle Twinkler Perc - Default: 1.00 -
float particleTwinkleScaleX                    = 1.00f; // Particle Twinkle X ----- Default: 1.00 -
float particleTwinkleScaleY                    = 1.00f; // Particle Twinkle Y ----- Default: 1.00 -
float particleBurst                            = 1.00f; // Particle Burst --------- Default: 1.00 -
float particleDrag                             = 1.00f; // Particle Drag ---------- Default: 1.00 -
float particleSpin                             = 1.00f; // Particle Spin ---------- Default: 1.00 -
float particleTumbleMinX                       = 1.00f; // Particle Tumble Min X -- Default: 1.00 -
float particleTumbleMinY                       = 1.00f; // Particle Tumble Min Y -- Default: 1.00 -
float particleTumbleMinZ                       = 1.00f; // Particle Tumble Min Z -- Default: 1.00 -
float particleTumbleMaxX                       = 1.00f; // Particle Tumble Max X -- Default: 1.00 -
float particleTumbleMaxY                       = 1.00f; // Particle Tumble Max X -- Default: 1.00 -
float particleTumbleMaxZ                       = 1.00f; // Particle Tumble Max X -- Default: 1.00 -
float particleWindVectorX                      = 1.00f; // Particle Wind Vector X - Default: 1.00 -
float particleWindVectorY                      = 1.00f; // Particle Wind Vector Y - Default: 1.00 -
float particleWindVectorZ                      = 1.00f; // Particle Wind Vector Z - Default: 1.00 -
float particleWindTime                         = 1.00f; // Particle Wind Time ----- Default: 1.00 -
float particleFollowSpeed1                     = 1.00f; // Particle Follow Speed1 - Default: 1.00 -
float particleFollowScale1                     = 1.00f; // Particle Follow Scale1 - Default: 1.00 -
float particleFollowSpeed2                     = 1.00f; // Particle Follow Speed2 - Default: 1.00 -
float particleFollowScale2                     = 1.00f; // Particle Follow Scale2 - Default: 1.00 -
byte particleEnabledBool                       = 1;     // Particle Enabled ------- Default: 1.00 -
// ==== Basic Scaling Override ====================================================================
if (basicScaling)
{
    // Sequence
    sequencePositionX           = basicModifierX;
    sequencePositionY           = basicModifierY;
    sequencePositionZ           = basicModifierZ;
    sequencePositionR           = basicModifierR;
    // Translation
    boneTranslationPositionX    = basicModifierX;
    boneTranslationPositionY    = basicModifierY;
    boneTranslationPositionZ    = basicModifierZ;
    // Pivot
    bonePivotPositionX          = basicModifierX;
    bonePivotPositionY          = basicModifierY;
    bonePivotPositionZ          = basicModifierZ;
    // Vertice
    verticePositionX            = basicModifierX;
    verticePositionY            = basicModifierY;
    verticePositionZ            = basicModifierZ;
    // Bounding
    boundingPositionX           = basicModifierX;
    boundingPositionY           = basicModifierY;
    boundingPositionZ           = basicModifierZ;
    boundingPositionR           = basicModifierR;
    // Collision
    collisionPositionX          = basicModifierX;
    collisionPositionY          = basicModifierY;
    collisionPositionZ          = basicModifierZ;
    collisionPositionR          = basicModifierR;
    // Attachment
    attachmentPositionX         = basicModifierX;
    attachmentPositionY         = basicModifierY;
    attachmentPositionZ         = basicModifierZ;
    // Event
    eventPositionX              = basicModifierX;
    eventPositionY              = basicModifierY;
    eventPositionZ              = basicModifierZ;
    // Light
    lightPositionX              = basicModifierX;
    lightPositionY              = basicModifierY;
    lightPositionZ              = basicModifierZ;
    // Ribbon
    ribbonPositionX             = basicModifierX;
    ribbonPositionY             = basicModifierY;
    ribbonPositionZ             = basicModifierZ;
    // Particle
    particlePositionX           = basicModifierX;
    particlePositionY           = basicModifierY;
    particlePositionZ           = basicModifierZ;
}
// ================================================================================================
///////////////////////////////////////////////////////////////////////////////////////////////////
//// DATA TYPES ///////////////////////////////////////////////////////////////////////////////////
// ==== INITIALIZERS ==============================================================================
float shortMax = 32767;                                 // Max Short ------------- Default: 32767 -
float floatOne = 1.00;                                  // Float 1.00 ------------- Default: 1.00 -
int byteSize = 0x01;                                    // Byte Size -------------- Default: 0x02 -
int shortSize = 0x02;                                   // Short Size ------------- Default: 0x02 -
int floatSize = 0x04;                                   // Float Size ------------- Default: 0x04 -
int intSize = 0x04;                                     // Int Size --------------- Default: 0x04 -
int quaternionSize = 0x08;                              // C4Quaternion Size ------ Default: 0x08 -
int vectorSize = 0x0C;                                  // C3Vector Size ---------- Default: 0x0C -
int startOffset = 0x00;                                 // File Start ------------- Default: 0x00 -
int versionOffset = 0x04;                               // File Version Offset ---- Default: 0x04 -
int version = ReadUInt(versionOffset);                  // File Version ---------------------------
int expansion = 0;                                      // Expansion ID ------ Default: 0 (Alpha) -
int fileSize = FileSize();                              // Max Byte Count -------------------------
int outputIter, blockIter, trackIter, subIter, pos;     // Int ------------------------------------
int currentTrack;                                       // Int ------------------------------------
uint16 trackInterpolation;                              // Interpolation - Default: offset + 0x00 -
int16 trackGlobalSeq;                                   // Global Seq. --- Default: offset + 0x02 -
uint32 trackRanges;                                     // Ranges -------- Default: offset + 0x04 -
uint32 trackRangesOffset;                               // Offset -------- Default: offset + 0x08 -
uint32 trackTimestamps;                                 // Timestamp ----- Default: offset + 0x0C -
uint32 trackTimestampsOffset;                           // Offset -------- Default: offset + 0x10 -
uint32 trackKeyPairs;                                   // Key Pairs ----- Default: offset + 0x14 -
uint32 trackKeyPairsOffset;                             // Offset -------- Default: offset + 0x18 -
float r, g, b, a, x, y, z, w, x2, y2, z2, x3, y3, z3;   // Float ----------------------------------
short sx, sy, sz, sw;                                   // Short ----------------------------------
wchar_t fileName[], filePath[], rootFile[], animFile[]; // Wchar_t --------------------------------
int subtrackCount;                                      // WotLK+ Subtrack Count -- Default: 0x00 -
int subtrackOffset;                                     // WotLK+ Subtrack Offset - Default: 0x00 -
int subtrackSize = 0x08;                                // WotLK+ Subtrack Size --- Default: 0x08 -
// ==== SEQUENCE ==================================================================================
int sequenceCount;                                      // Sequence Count --------- Default: 0x1C -
int sequenceOffset;                                     // Sequence Offset -------- Default: 0x20 -
int sequenceSize;                                       // Sequence Size ---------- Default: 0x44 -
uint16 sequenceId;                                      // Sequence Id ------------ Default: 0x00 -
int sequenceIdPadding;                                  // Sequence Id Padding ---- Default: 0x00 -
uint16 sequenceSub;                                     // Sequence Sub Id -------- Default: 0x00 -
int sequenceSubPadding;                                 // Sequence Sub Padding --- Default: 0x02 -
int sequenceFlags;                                      // Sequence Flags --------- Default: 0x00 -
int sequenceFlagPadding;                                // Sequence Flag Padding -- Default: 0x10 -
int sequencePositionPadding;                            // Sequence Padding ------- Default: 0x24 -
// ==== BONE ======================================================================================
int boneCount;                                          // Bone Count ------------- Default: 0x34 -
int boneOffset;                                         // Bone[0] Offset --------- Default: 0x38 -
int boneSize;                                           // Bone Size -------------- Default: 0x6C -
int boneTranslationPadding;                             // Translation Padding ---- Default: 0x0C -
int boneTranslationOffset;                              // Translation Offset - boneOffset + 0x0C -
int boneTranslationSize;                                // Translation Size ------- Default: 0x0C -
int boneRotationPadding;                                // Rotation Padding ------- Default: 0x28 -
int boneRotationOffset;                                 // Rotation Offset ---- boneOffset + 0x1C -
int boneRotationSize;                                   // Rotation Size ---------- Default: 0x08 -
int boneScalingPadding;                                 // Scaling Padding -------- Default: 0x44 -
int boneScalingOffset;                                  // Scaling ------------ boneOffset + 0x1C -
int boneScalingSize;                                    // Scaling Size ----------- Default: 0x0C -
int bonePivotPadding;                                   // Bone Pivot Padding ----- Default: 0x60 -
// ==== VERTICE ===================================================================================
int verticeCount;                                       // Vertice Count ---------- Default: 0x44 -
int verticeOffset;                                      // Vertice Offset --------- Default: 0x48 -
int verticeSize;                                        // Vertice Size ----------- Default: 0x30 -
int verticePositionPadding;                             // Vertice Padding -------- Default: 0x00 -
// ==== COLOR =====================================================================================
int colorCount;                                         // Color Count ------------ Default: 0x54 -
int colorOffset;                                        // Color Offset ----------- Default: 0x58 -
int colorSize;                                          // Color Size ------------- Default: 0x38 -
int colorColorPadding;                                  // ColorColor Padding ----- Default: 0x00 -
int colorColorOffset;                                   // ColorColor Offset - colorOffset + 0x00 -
int colorColorSize;                                     // ColorColor Size -------- Default: 0x1C -
int colorAlphaPadding;                                  // ColorAlpha Padding ----- Default: 0x1C -
int colorAlphaOffset;                                   // ColorAlpha Offset - colorOffset + 0x1C -
int colorAlphaSize;                                     // ColorAlpha Size -------- Default: 0x1C -
// ==== WEIGHT ====================================================================================
int weightCount;                                        // Weight Count ----------- Default: 0x64 -
int weightOffset;                                       // Weight Offset ---------- Default: 0x68 -
int weightSize;                                         // Weight Size ------------ Default: 0x1C -
// ==== TRANSFORM =================================================================================
int transformCount;                                     // Transform Count -------- Default: 0x74 -
int transformOffset;                                    // Transform Offset ------- Default: 0x78 -
int transformSize;                                      // Transform Size --------- Default: 0x54 -
int transformTranslationPadding;                        // Translation Padding ---- Default: 0x00 -
int transformTranslationOffset;                         // Translation Offset ----- Default: 0x00 -
int transformTranslationSize;                           // Translation Size ------- Default: 0x1C -
int transformScalingPadding;                            // Scaling Padding -------- Default: 0x1C -
int transformScalingOffset;                             // Scaling Offset --------- Default: 0x1C -
int transformScalingSize;                               // Scaling Size ----------- Default: 0x1C -
int transformRotationPadding;                           // Rotation Padding ------- Default: 0x38 -
int transformRotationOffset;                            // Rotation Offset -------- Default: 0x38 -
int transformRotationSize;                              // Rotation Size ---------- Default: 0x1C -
// ==== BOUNDING ==================================================================================
int boundingOffset;                                     // Bounding Offset -------- Default: 0xB4 -
int boundingSize;                                       // Bounding Size ---------- Default: 0x38 -
int boundingRadius;                                     // Bounding Radius -------- Default: 0x18 -
// ==== COLLISION =================================================================================
int collisionBoxPadding;                                // Collision Box Padding -- Default: 0x1C -
int collisionRadius;                                    // Collision Radius ------- Default: 0x34 -
int collisionCount;                                     // Collision Count -------- Default: 0xF4 -
int collisionOffset;                                    // Collision Offset ------- Default: 0xF8 -
int collisionSize;                                      // Collision Size --------- Default: 0x0C -
// ==== NORMAL ====================================================================================
int normalCount;                                        // Normal Count ----------- Default: 0xFC -
int normalOffset;                                       // Normal Offset --------- Default: 0x100 -
int normalSize;                                         // Normal Size ------------ Default: 0x0C -
// ==== ATTACHMENT ================================================================================
int attachmentCount;                                    // Attachment Count ------ Default: 0x104 -
int attachmentOffset;                                   // Attachment Offset ----- Default: 0x108 -
int attachmentSize;                                     // Attachment Size -------- Default: 0x30 -
int attachmentPositionPadding;                          // Attachment Padding ----- Default: 0x24 -
// ==== EVENT =====================================================================================
int eventCount;                                         // Event Count ----------- Default: 0x114 -
int eventOffset;                                        // Event Offset ---------- Default: 0x118 -
int eventSize;                                          // Event Size ------------- Default: 0x2C -
int eventPositionPadding;                               // Event Padding ---------- Default: 0x0C -
// ==== LIGHT =====================================================================================
int lightCount;                                         // Light Count ----------- Default: 0x11C -
int lightOffset;                                        // Light Offset ---------- Default: 0x118 -
int lightSize;                                          // Light Size ------------- Default: 0xD4 -
int lightPositionPadding;                               // Light Padding ---------- Default: 0x04 -
int lightAmbientColorPadding;
int lightAmbientColorOffset;
int lightAmbientColorSize;
int lightAmbientIntensityPadding;
int lightAmbientIntensityOffset;
int lightAmbientIntensitySize;
int lightDiffuseColorPadding;
int lightDiffuseColorOffset;
int lightDiffuseColorSize;
int lightDiffuseIntensityPadding;
int lightDiffuseIntensityOffset;
int lightDiffuseIntensitySize;
int lightAttenuationStartPadding;
int lightAttenuationStartOffset;
int lightAttenuationStartSize;
int lightAttenuationEndPadding;
int lightAttenuationEndOffset;
int lightAttenuationEndSize;
int lightVisibilityPadding;
int lightVisibilityOffset;
int lightVisibilitySize;
// ==== CAMERA ====================================================================================
int cameraCount;                                        // Camera Count ---------- Default: 0x124 -
int cameraOffset;                                       // Camera Offset --------- Default: 0x128 -
int cameraSize;                                         // Camera Size ------------ Default: 0x7C -
int cameraFovPadding;
int cameraFarclipPadding;
int cameraNearclipPadding;
int cameraTranslationPosPadding;
int cameraTranslationPosOffset;
int cameraTranslationPosSize;
int cameraPositionPadding;                              // Camera Padding --------- Default: 0x24 -
int cameraTranslationTarPadding;
int cameraTranslationTarOffset;
int cameraTranslationTarSize;
int cameraTargetPadding;
int cameraRollPadding;
int cameraRollOffset;
int cameraRollSize;
// ==== RIBBON ====================================================================================
int ribbonCount;                                        // Ribbon Count ---------- Default: 0x134 -
int ribbonOffset;                                       // Ribbon Offset --------- Default: 0x138 -
int ribbonSize;                                         // Ribbon Size ------------ Default: 0xDC -
int ribbonPositionPadding;                              // Ribbon Padding --------- Default: 0x08 -
int ribbonColorPadding;
int ribbonColorOffset;
int ribbonColorSize;
int ribbonAlphaPadding;
int ribbonAlphaOffset;
int ribbonAlphaSize;
int ribbonHeightAbovePadding;
int ribbonHeightAboveOffset;
int ribbonHeightAboveSize;
int ribbonHeightBelowPadding;
int ribbonHeightBelowOffset;
int ribbonHeightBelowSize;
int ribbonEdgeRatePadding;
int ribbonEdgeLifespanPadding;
int ribbonGravityPadding;
int ribbonVisibilityPadding;
int ribbonVisibilityOffset;
int ribbonVisibilitySize;
// ==== PARTICLE ==================================================================================
int particleCount;                                      // Particle Count -------- Default: 0x13C -
int particleOffset;                                     // Particle Offset ------- Default: 0x140 -
int particleSize;                                       // Particle Size --------- Default: 0x1F8 -
int particlePositionPadding;                            // Particle Padding ------- Default: 0x24 -
int particleEmissionSpeedPadding;
int particleEmissionSpeedOffset;
int particleEmissionSpeedSize;
int particleSpeedPadding;
int particleSpeedOffset;
int particleSpeedSize;
int particleVerticalPadding;
int particleVerticalOffset;
int particleVerticalSize;
int particleHorizontalPadding;
int particleHorizontalOffset;
int particleHorizontalSize;
int particleGravityPadding;
int particleGravityOffset;
int particleGravitySize;
int particleLifespanPadding;
int particleLifespanOffset;
int particleLifespanSize;
int particleLifespanVaryPadding;
int particleEmissionRatePadding;
int particleEmissionRateOffset;
int particleEmissionRateSize;
int particleEmissionRateVaryPadding;
int particleEmissionLengthPadding;
int particleEmissionLengthOffset;
int particleEmissionLengthSize;
int particleEmissionWidthPadding;
int particleEmissionWidthOffset;
int particleEmissionWidthSize;
int particleSourcePadding;
int particleSourceOffset;
int particleSourceSize;
int particleMidpointPadding;
int particleColorPadding;
int particleColorOffset;
int particleColorSize;
int particleAlphaPadding;
int particleAlphaOffset;
int particleAlphaSize;
int particleScalePadding;
int particleScaleOffset;
int particleScaleSize;
int particleScaleVaryPadding;
int particleTailLengthPadding;
int particleTwinkleSpeedPadding;
int particleTwinklePercentPadding;
int particleTwinkleScalePadding;
int particleBurstPadding;
int particleDragPadding;
int particleBaseSpinPadding;
int particleBaseSpinVaryPadding;
int particleSpinPadding;
int particleSpinVaryPadding;
int particleTumbleMinPadding;
int particleTumbleMaxPadding;
int particleWindVectorPadding;
int particleWindTimePadding;
int particleFollowSpeed1Padding;
int particleFollowScale1Padding;
int particleFollowSpeed2Padding;
int particleFollowScale2Padding;
int particleEnabledPadding;
int particleEnabledOffset;
int particleEnabledSize;
// ================================================================================================
///////////////////////////////////////////////////////////////////////////////////////////////////
//// HELPERS //////////////////////////////////////////////////////////////////////////////////////
// ==== Short to Float ============================================================================
float stf(unsigned short s)
{ 
    return (s / shortMax) - floatOne; 
}
// ==== Float to Short ============================================================================
unsigned short fts(float f)
{ 
    return (f + floatOne) * shortMax; 
}
// ==== Version ===================================================================================
filePath = FileNameGetPathW(GetFileNameW());
fileName = FileNameGetBase(GetFileNameW(), false);
rootFile = Str("%s%s.m2", filePath, fileName);
Printf( "File Path: %s, M2 Name: %s \n", filePath, fileName );
if (version)
{
    if (version == 256)
    {
        Printf("File Version [%u] - Set to Alpha mode\n", version);
        // Expansion
        expansion                       = 0; // Alpha
        // Sequence
        sequenceCount                   = ReadUInt(startOffset + 0x1C);
        sequenceOffset                  = ReadUInt(startOffset + 0x20);
        sequenceSize                    = 0x44;
        sequenceIdPadding               = 0x00;
        sequenceSubPadding              = 0x02;
        sequenceFlagPadding             = 0x10;
        sequencePositionPadding         = 0x24;
        // Bone
        boneCount                       = ReadUInt(startOffset + 0x34);
        boneOffset                      = ReadUInt(startOffset + 0x38);
        boneSize                        = 0x6C;
        boneTranslationPadding          = 0x0C;
        boneTranslationOffset           = boneOffset + boneTranslationPadding;
        boneTranslationSize             = 0x1C;
        boneRotationPadding             = 0x28;
        boneRotationOffset              = boneOffset + boneRotationPadding;
        boneRotationSize                = 0x1C;
        boneScalingPadding              = 0x44;
        boneScalingOffset               = boneOffset + boneScalingPadding;
        boneScalingSize                 = 0x1C;
        bonePivotPadding                = 0x60;
        // Vertice
        verticeCount                    = ReadUInt(startOffset + 0x44);
        verticeOffset                   = ReadUInt(startOffset + 0x48);
        verticeSize                     = 0x30;
        verticePositionPadding          = 0x00;
        // Color
        colorCount                      = ReadUInt(startOffset + 0x54);
        colorOffset                     = ReadUInt(startOffset + 0x58);
        colorSize                       = 0x38;
        colorColorPadding               = 0x00;
        colorColorOffset                = colorOffset + 0x00;
        colorColorSize                  = 0x1C;
        colorAlphaPadding               = 0x1C;
        colorAlphaOffset                = colorOffset + 0x1C;
        colorAlphaSize                  = 0x1C;
        // Weight
        weightCount                     = ReadUInt(startOffset + 0x64);
        weightOffset                    = ReadUInt(startOffset + 0x68);
        weightSize                      = 0x1C;
        // Transform
        transformCount                  = ReadUInt(startOffset + 0x74);
        transformOffset                 = ReadUInt(startOffset + 0x78);
        transformSize                   = 0x54;
        transformTranslationPadding     = 0x00;
        transformTranslationOffset      = transformOffset + transformTranslationPadding;
        transformTranslationSize        = 0x1C;
        transformRotationPadding        = 0x1C;
        transformRotationOffset         = transformOffset + transformRotationPadding;
        transformRotationSize           = 0x1C;
        transformScalingPadding         = 0x38;
        transformScalingOffset          = transformOffset + transformScalingPadding;
        transformScalingSize            = 0x1C;
        // Bounding
        boundingOffset                  = 0xB4;
        boundingSize                    = 0x38;
        boundingRadius                  = 0x18;
        // Collision
        collisionBoxPadding             = 0x1C;
        collisionRadius                 = 0x34;
        collisionCount                  = ReadUInt(startOffset + 0xF4);
        collisionOffset                 = ReadUInt(startOffset + 0xF8);
        collisionSize                   = 0x0C;
        // Normal
        normalCount                     = ReadUInt(startOffset + 0xFC);
        normalOffset                    = ReadUInt(startOffset + 0x100);
        normalSize                      = 0x0C;
        // Attachment
        attachmentCount                 = ReadUInt(startOffset + 0x104);
        attachmentOffset                = ReadUInt(startOffset + 0x108);
        attachmentSize                  = 0x30;
        attachmentPositionPadding       = 0x08;
        // Event
        eventCount                      = ReadUInt(startOffset + 0x114);
        eventOffset                     = ReadUInt(startOffset + 0x118);
        eventSize                       = 0x2C;
        eventPositionPadding            = 0x0C;
        // Light
        lightCount                      = ReadUInt(startOffset + 0x11C);
        lightOffset                     = ReadUInt(startOffset + 0x120);
        lightSize                       = 0xD4;
        lightPositionPadding            = 0x04;
        lightAmbientColorPadding        = 0x10;
        lightAmbientColorOffset         = lightOffset + lightAmbientColorPadding;
        lightAmbientColorSize           = 0x1C;
        lightAmbientIntensityPadding    = 0x2C;
        lightAmbientIntensityOffset     = lightOffset + lightAmbientIntensityPadding;
        lightAmbientIntensitySize       = 0x1C;
        lightDiffuseColorPadding        = 0x48;
        lightDiffuseColorOffset         = lightOffset + lightDiffuseColorPadding;
        lightDiffuseColorSize           = 0x1C;
        lightDiffuseIntensityPadding    = 0x64;
        lightDiffuseIntensityOffset     = lightOffset + lightDiffuseIntensityPadding;
        lightDiffuseIntensitySize       = 0x1C;
        lightAttenuationStartPadding    = 0x80;
        lightAttenuationStartOffset     = lightOffset + lightAttenuationStartPadding;
        lightAttenuationStartSize       = 0x1C;
        lightAttenuationEndPadding      = 0x9C;
        lightAttenuationEndOffset       = lightOffset + lightAttenuationEndPadding;
        lightAttenuationEndSize         = 0x1C;
        lightVisibilityPadding          = 0xB8;
        lightVisibilityOffset           = lightOffset + lightVisibilityPadding;
        lightVisibilitySize             = 0x1C;
        // Camera
        cameraCount                     = ReadUInt(startOffset + 0x124);
        cameraOffset                    = ReadUInt(startOffset + 0x128);
        cameraSize                      = 0x7C;
        cameraFovPadding                = 0x04;
        cameraFarclipPadding            = 0x08;
        cameraNearclipPadding           = 0x0C;
        cameraTranslationPosPadding     = 0x10;
        cameraTranslationPosOffset      = cameraOffset + cameraTranslationPosPadding;
        cameraTranslationPosSize        = 0x1C;
        cameraPositionPadding           = 0x2C;
        cameraTranslationTarPadding     = 0x38;
        cameraTranslationTarOffset      = cameraOffset + cameraTranslationTarPadding;
        cameraTranslationTarSize        = 0x1C;
        cameraTargetPadding             = 0x54;
        cameraRollPadding               = 0x60;
        cameraRollOffset                = cameraOffset + cameraRollPadding;
        cameraRollSize                  = 0x1C;
        // Ribbon
        ribbonCount                     = ReadUInt(startOffset + 0x134);
        ribbonOffset                    = ReadUInt(startOffset + 0x138);
        ribbonSize                      = 0xDC;
        ribbonPositionPadding           = 0x08;
        ribbonColorPadding              = 0x24;
        ribbonColorOffset               = ribbonOffset + ribbonColorPadding;
        ribbonColorSize                 = 0x1C;
        ribbonAlphaPadding              = 0x40;
        ribbonAlphaOffset               = ribbonOffset + ribbonAlphaPadding;
        ribbonAlphaSize                 = 0x1C;
        ribbonHeightAbovePadding        = 0x5C;
        ribbonHeightAboveOffset         = ribbonOffset + ribbonHeightAbovePadding;
        ribbonHeightAboveSize           = 0x1C;
        ribbonHeightBelowPadding        = 0x78;
        ribbonHeightBelowOffset         = ribbonOffset + ribbonHeightBelowPadding;
        ribbonHeightBelowSize           = 0x1C;
        ribbonEdgeRatePadding           = 0x94;
        ribbonEdgeLifespanPadding       = 0x98;
        ribbonGravityPadding            = 0x9C;
        ribbonVisibilityPadding         = 0xC0;
        ribbonVisibilityOffset          = ribbonOffset + ribbonVisibilityPadding;
        ribbonVisibilitySize            = 0x1C;
        // Particle
        particleCount                   = ReadUInt(startOffset + 0x13C);
        particleOffset                  = ReadUInt(startOffset + 0x140);
        particleSize                    = 0x1F8;
        particlePositionPadding         = 0x08;
        particleEmissionSpeedPadding    = 0x34;
        particleEmissionSpeedOffset     = particleOffset + particleEmissionSpeedPadding;
        particleEmissionSpeedSize       = 0x1C;
        particleSpeedPadding            = 0x50;
        particleSpeedOffset             = particleOffset + particleSpeedPadding;
        particleSpeedSize               = 0x1C;
        particleVerticalPadding         = 0x6C;
        particleVerticalOffset          = particleOffset + particleVerticalPadding;
        particleVerticalSize            = 0x1C;
        particleHorizontalPadding       = 0x88;
        particleHorizontalOffset        = particleOffset + particleHorizontalPadding;
        particleHorizontalSize          = 0x1C;
        particleGravityPadding          = 0xA4;
        particleGravityOffset           = particleOffset + particleGravityPadding;
        particleGravitySize             = 0x1C;
        particleLifespanPadding         = 0xC0;
        particleLifespanOffset          = particleOffset + particleLifespanPadding;
        particleLifespanSize            = 0x1C;
        particleEmissionRatePadding     = 0xDC;
        particleEmissionRateOffset      = particleOffset + particleEmissionRateOffset;
        particleEmissionRateSize        = 0x1C;
        particleEmissionLengthPadding   = 0xF8;
        particleEmissionLengthOffset    = particleOffset + particleEmissionLengthPadding;
        particleEmissionLengthSize      = 0x1C;
        particleEmissionWidthPadding    = 0x114;
        particleEmissionWidthOffset     = particleOffset + particleEmissionWidthPadding;
        particleEmissionWidthSize       = 0x1C;
        particleSourcePadding           = 0x130;
        particleSourceOffset            = particleOffset + particleSourcePadding;
        particleSourceSize              = 0x1C;
        particleMidpointPadding         = 0x14C;
        particleColorPadding            = 0x150;
        particleScalePadding            = 0x15C;
        particleTailLengthPadding       = 0x17C;
        particleTwinkleSpeedPadding     = 0x180;
        particleTwinklePercentPadding   = 0x184;
        particleTwinkleScalePadding     = 0x188;
        particleBurstPadding            = 0x190;
        particleDragPadding             = 0x194;
        particleSpinPadding             = 0x198;
        particleTumbleMinPadding        = 0x19C;
        particleTumbleMaxPadding        = 0x1A8;
        particleWindVectorPadding       = 0x1B4;
        particleWindTimePadding         = 0x1C0;
        particleFollowSpeed1Padding     = 0x1C4;
        particleFollowScale1Padding     = 0x1C8;
        particleFollowSpeed2Padding     = 0x1CC;
        particleFollowScale2Padding     = 0x1D0;
        particleEnabledPadding          = 0x1DC;
        particleEnabledOffset           = particleOffset + particleEnabledPadding;
        particleEnabledSize             = 0x1C;
    }
    if (version >= 257 && version < 260)
    {
        Printf("File Version [%u] - Set to Vanilla mode\n", version);
        // Expansion
        expansion                       = 1; // Vanilla
        // Sequence
        sequenceCount                   = ReadUInt(startOffset + 0x1C);
        sequenceOffset                  = ReadUInt(startOffset + 0x20);
        sequenceSize                    = 0x44;
        sequenceIdPadding               = 0x00;
        sequenceSubPadding              = 0x02;
        sequenceFlagPadding             = 0x10;
        sequencePositionPadding         = 0x24;
        // Bone
        boneCount                       = ReadUInt(startOffset + 0x34);
        boneOffset                      = ReadUInt(startOffset + 0x38);
        boneSize                        = 0x6C;
        boneTranslationPadding          = 0x0C;
        boneTranslationOffset           = boneOffset + boneTranslationPadding;
        boneTranslationSize             = 0x1C;
        boneRotationPadding             = 0x28;
        boneRotationOffset              = boneOffset + boneRotationPadding;
        boneRotationSize                = 0x1C;
        boneScalingPadding              = 0x44;
        boneScalingOffset               = boneOffset + boneScalingPadding;
        boneScalingSize                 = 0x1C;
        bonePivotPadding                = 0x60;
        // Vertice
        verticeCount                    = ReadUInt(startOffset + 0x44);
        verticeOffset                   = ReadUInt(startOffset + 0x48);
        verticeSize                     = 0x30;
        verticePositionPadding          = 0x00;
        // Color
        colorCount                      = ReadUInt(startOffset + 0x54);
        colorOffset                     = ReadUInt(startOffset + 0x58);
        colorSize                       = 0x38;
        colorColorPadding               = 0x00;
        colorColorOffset                = colorOffset + 0x00;
        colorColorSize                  = 0x1C;
        colorAlphaPadding               = 0x1C;
        colorAlphaOffset                = colorOffset + 0x1C;
        colorAlphaSize                  = 0x1C;
        // Weight
        weightCount                     = ReadUInt(startOffset + 0x64);
        weightOffset                    = ReadUInt(startOffset + 0x68);
        weightSize                      = 0x1C;
        // Transform
        transformCount                  = ReadUInt(startOffset + 0x74);
        transformOffset                 = ReadUInt(startOffset + 0x78);
        transformSize                   = 0x54;
        transformTranslationPadding     = 0x00;
        transformTranslationOffset      = transformOffset + transformTranslationPadding;
        transformTranslationSize        = 0x1C;
        transformRotationPadding        = 0x1C;
        transformRotationOffset         = transformOffset + transformRotationPadding;
        transformRotationSize           = 0x1C;
        transformScalingPadding         = 0x38;
        transformScalingOffset          = transformOffset + transformScalingPadding;
        transformScalingSize            = 0x1C;
        // Bounding
        boundingOffset                  = 0xB4;
        boundingSize                    = 0x38;
        boundingRadius                  = 0x18;
        // Collision
        collisionBoxPadding             = 0x1C;
        collisionRadius                 = 0x34;
        collisionCount                  = ReadUInt(startOffset + 0xF4);
        collisionOffset                 = ReadUInt(startOffset + 0xF8);
        collisionSize                   = 0x0C;
        // Normal
        normalCount                     = ReadUInt(startOffset + 0xFC);
        normalOffset                    = ReadUInt(startOffset + 0x100);
        normalSize                      = 0x0C;
        // Attachment
        attachmentCount                 = ReadUInt(startOffset + 0x104);
        attachmentOffset                = ReadUInt(startOffset + 0x108);
        attachmentSize                  = 0x30;
        attachmentPositionPadding       = 0x08;
        // Event
        eventCount                      = ReadUInt(startOffset + 0x114);
        eventOffset                     = ReadUInt(startOffset + 0x118);
        eventSize                       = 0x2C;
        eventPositionPadding            = 0x0C;
        // Light
        lightCount                      = ReadUInt(startOffset + 0x11C);
        lightOffset                     = ReadUInt(startOffset + 0x120);
        lightSize                       = 0xD4;
        lightPositionPadding            = 0x04;
        lightAmbientColorPadding        = 0x10;
        lightAmbientColorOffset         = lightOffset + lightAmbientColorPadding;
        lightAmbientColorSize           = 0x1C;
        lightAmbientIntensityPadding    = 0x2C;
        lightAmbientIntensityOffset     = lightOffset + lightIntensityPadding;
        lightAmbientIntensitySize       = 0x1C;
        lightDiffuseColorPadding        = 0x48;
        lightDiffuseColorOffset         = lightOffset + lightDiffuseColorPadding;
        lightDiffuseColorSize           = 0x1C;
        lightDiffuseIntensityPadding    = 0x64;
        lightDiffuseIntensityOffset     = lightOffset + lightDiffuseIntensityPadding;
        lightDiffuseIntensitySize       = 0x1C;
        lightAttenuationStartPadding    = 0x80;
        lightAttenuationStartOffset     = lightOffset + lightAttenuationStartPadding;
        lightAttenuationStartSize       = 0x1C;
        lightAttenuationEndPadding      = 0x9C;
        lightAttenuationEndOffset       = lightOffset + lightAttenuationEndPadding;
        lightAttenuationEndSize         = 0x1C;
        lightVisibilityPadding          = 0xB8;
        lightVisibilityOffset           = lightOffset + lightVisibilityPadding;
        lightVisibilitySize             = 0x1C;
        // Camera
        cameraCount                     = ReadUInt(startOffset + 0x124);
        cameraOffset                    = ReadUInt(startOffset + 0x128);
        cameraSize                      = 0x7C;
        cameraFovPadding                = 0x04;
        cameraFarclipPadding            = 0x08;
        cameraNearclipPadding           = 0x0C;
        cameraTranslationPosPadding     = 0x10;
        cameraTranslationPosOffset      = cameraOffset + cameraTranslationPosPadding;
        cameraTranslationPosSize        = 0x1C;
        cameraPositionPadding           = 0x2C;
        cameraTranslationTarPadding     = 0x38;
        cameraTranslationTarOffset      = cameraOffset + cameraTranslationTarPadding;
        cameraTranslationTarSize        = 0x1C;
        cameraTargetPadding             = 0x54;
        cameraRollPadding               = 0x60;
        cameraRollOffset                = cameraOffset + cameraRollPadding;
        cameraRollSize                  = 0x1C;
        // Ribbon
        ribbonCount                     = ReadUInt(startOffset + 0x134);
        ribbonOffset                    = ReadUInt(startOffset + 0x138);
        ribbonSize                      = 0xDC;
        ribbonPositionPadding           = 0x08;
        ribbonColorPadding              = 0x24;
        ribbonColorOffset               = ribbonOffset + ribbonColorPadding;
        ribbonColorSize                 = 0x1C;
        ribbonAlphaPadding              = 0x40;
        ribbonAlphaOffset               = ribbonOffset + ribbonAlphaPadding;
        ribbonAlphaSize                 = 0x1C;
        ribbonHeightAbovePadding        = 0x5C;
        ribbonHeightAboveOffset         = ribbonOffset + ribbonHeightAbovePadding;
        ribbonHeightAboveSize           = 0x1C;
        ribbonHeightBelowPadding        = 0x78;
        ribbonHeightBelowOffset         = ribbonOffset + ribbonHeightBelowPadding;
        ribbonHeightBelowSize           = 0x1C;
        ribbonEdgeRatePadding           = 0x94;
        ribbonEdgeLifespanPadding       = 0x98;
        ribbonGravityPadding            = 0x9C;
        ribbonVisibilityPadding         = 0xC0;
        ribbonVisibilityOffset          = ribbonOffset + ribbonVisibilityPadding;
        ribbonVisibilitySize            = 0x1C;
        // Particle
        particleCount                   = ReadUInt(startOffset + 0x13C);
        particleOffset                  = ReadUInt(startOffset + 0x140);
        particleSize                    = 0x1F8;
        particlePositionPadding         = 0x08;
        particleEmissionSpeedPadding    = 0x34;
        particleEmissionSpeedOffset     = particleOffset + particleEmissionSpeedPadding;
        particleEmissionSpeedSize       = 0x1C;
        particleSpeedPadding            = 0x50;
        particleSpeedOffset             = particleOffset + particleSpeedPadding;
        particleSpeedSize               = 0x1C;
        particleVerticalPadding         = 0x6C;
        particleVerticalOffset          = particleOffset + particleVerticalPadding;
        particleVerticalSize            = 0x1C;
        particleHorizontalPadding       = 0x88;
        particleHorizontalOffset        = particleOffset + particleHorizontalPadding;
        particleHorizontalSize          = 0x1C;
        particleGravityPadding          = 0xA4;
        particleGravityOffset           = particleOffset + particleGravityPadding;
        particleGravitySize             = 0x1C;
        particleLifespanPadding         = 0xC0;
        particleLifespanOffset          = particleOffset + particleLifespanPadding;
        particleLifespanSize            = 0x1C;
        particleEmissionRatePadding     = 0xDC;
        particleEmissionRateOffset      = particleOffset + particleEmissionRateOffset;
        particleEmissionRateSize        = 0x1C;
        particleEmissionLengthPadding   = 0xF8;
        particleEmissionLengthOffset    = particleOffset + particleEmissionLengthPadding;
        particleEmissionLengthSize      = 0x1C;
        particleEmissionWidthPadding    = 0x114;
        particleEmissionWidthOffset     = particleOffset + particleEmissionWidthPadding;
        particleEmissionWidthSize       = 0x1C;
        particleSourcePadding           = 0x130;
        particleSourceOffset            = particleOffset + particleSourcePadding;
        particleSourceSize              = 0x1C;
        particleMidpointPadding         = 0x14C;
        particleColorPadding            = 0x150;
        particleScalePadding            = 0x15C;
        particleTailLengthPadding       = 0x17C;
        particleTwinkleSpeedPadding     = 0x180;
        particleTwinklePercentPadding   = 0x184;
        particleTwinkleScalePadding     = 0x188;
        particleBurstPadding            = 0x190;
        particleDragPadding             = 0x194;
        particleSpinPadding             = 0x198;
        particleTumbleMinPadding        = 0x19C;
        particleTumbleMaxPadding        = 0x1A8;
        particleWindVectorPadding       = 0x1B4;
        particleWindTimePadding         = 0x1C0;
        particleFollowSpeed1Padding     = 0x1C4;
        particleFollowScale1Padding     = 0x1C8;
        particleFollowSpeed2Padding     = 0x1CC;
        particleFollowScale2Padding     = 0x1D0;
        particleEnabledPadding          = 0x1DC;
        particleEnabledOffset           = particleOffset + particleEnabledPadding;
        particleEnabledSize             = 0x1C;
    }
    if (version >= 260 && version < 264)
    {
        Printf("File Version [%u] - Set to The Burning Crusade mode\n", version);
        // Expansion
        expansion                       = 2; // The Burning Crusade
        // Sequence
        sequenceCount                   = ReadUInt(startOffset + 0x1C);
        sequenceOffset                  = ReadUInt(startOffset + 0x20);
        sequenceSize                    = 0x44;
        sequenceIdPadding               = 0x00;
        sequenceSubPadding              = 0x02;
        sequenceFlagPadding             = 0x10;
        sequencePositionPadding         = 0x24;
        // Bone
        boneCount                       = ReadUInt(startOffset + 0x34);
        boneOffset                      = ReadUInt(startOffset + 0x38);
        boneSize                        = 0x70;
        boneTranslationPadding          = 0x10;
        boneTranslationOffset           = boneOffset + boneTranslationPadding;
        boneTranslationSize             = 0x1C;
        boneRotationPadding             = 0x2C;
        boneRotationOffset              = boneOffset + boneRotationPadding;
        boneRotationSize                = 0x1C;
        boneScalingPadding              = 0x48;
        boneScalingOffset               = boneOffset + boneScalingPadding;
        boneScalingSize                 = 0x1C;
        bonePivotPadding                = 0x64;
        // Vertice
        verticeCount                    = ReadUInt(startOffset + 0x44);
        verticeOffset                   = ReadUInt(startOffset + 0x48);
        verticeSize                     = 0x30;
        verticePositionPadding          = 0x00;
        // Color
        colorCount                      = ReadUInt(startOffset + 0x54);
        colorOffset                     = ReadUInt(startOffset + 0x58);
        colorSize                       = 0x38;
        colorColorPadding               = 0x00;
        colorColorOffset                = colorOffset + 0x00;
        colorColorSize                  = 0x1C;
        colorAlphaPadding               = 0x1C;
        colorAlphaOffset                = colorOffset + 0x1C;
        colorAlphaSize                  = 0x1C;
        // Weight
        weightCount                     = ReadUInt(startOffset + 0x64);
        weightOffset                    = ReadUInt(startOffset + 0x68);
        weightSize                      = 0x1C;
        // Transform
        transformCount                  = ReadUInt(startOffset + 0x74);
        transformOffset                 = ReadUInt(startOffset + 0x78);
        transformSize                   = 0x54;
        transformTranslationPadding     = 0x00;
        transformTranslationOffset      = transformOffset + transformTranslationPadding;
        transformTranslationSize        = 0x1C;
        transformRotationPadding        = 0x1C;
        transformRotationOffset         = transformOffset + transformRotationPadding;
        transformRotationSize           = 0x1C;
        transformScalingPadding         = 0x38;
        transformScalingOffset          = transformOffset + transformScalingPadding;
        transformScalingSize            = 0x1C;
        // Bounding
        boundingOffset                  = 0xB4;
        boundingSize                    = 0x38;
        boundingRadius                  = 0x18;
        // Collision
        collisionBoxPadding             = 0x1C;
        collisionRadius                 = 0x34;
        collisionCount                  = ReadUInt(startOffset + 0xF4);
        collisionOffset                 = ReadUInt(startOffset + 0xF8);
        collisionSize                   = 0x0C;
        // Normal
        normalCount                     = ReadUInt(startOffset + 0xFC);
        normalOffset                    = ReadUInt(startOffset + 0x100);
        normalSize                      = 0x0C;
        // Attachment
        attachmentCount                 = ReadUInt(startOffset + 0x104);
        attachmentOffset                = ReadUInt(startOffset + 0x108);
        attachmentSize                  = 0x30;
        attachmentPositionPadding       = 0x08;
        // Event
        eventCount                      = ReadUInt(startOffset + 0x114);
        eventOffset                     = ReadUInt(startOffset + 0x118);
        eventSize                       = 0x2C;
        eventPositionPadding            = 0x0C;
        // Light
        lightCount                      = ReadUInt(startOffset + 0x11C);
        lightOffset                     = ReadUInt(startOffset + 0x120);
        lightSize                       = 0xD4;
        lightPositionPadding            = 0x04;
        lightAmbientColorPadding        = 0x10;
        lightAmbientColorOffset         = lightOffset + lightAmbientColorPadding;
        lightAmbientColorSize           = 0x1C;
        lightAmbientIntensityPadding    = 0x2C;
        lightAmbientIntensityOffset     = lightOffset + lightAmbientIntensityPadding;
        lightAmbientIntensitySize       = 0x1C;
        lightDiffuseColorPadding        = 0x48;
        lightDiffuseColorOffset         = lightOffset + lightDiffuseColorPadding;
        lightDiffuseColorSize           = 0x1C;
        lightDiffuseIntensityPadding    = 0x64;
        lightDiffuseIntensityOffset     = lightOffset + lightDiffuseIntensityPadding;
        lightDiffuseIntensitySize       = 0x1C;
        lightAttenuationStartPadding    = 0x80;
        lightAttenuationStartOffset     = lightOffset + lightAttenuationStartPadding;
        lightAttenuationStartSize       = 0x1C;
        lightAttenuationEndPadding      = 0x9C;
        lightAttenuationEndOffset       = lightOffset + lightAttenuationEndPadding;
        lightAttenuationEndSize         = 0x1C;
        lightVisibilityPadding          = 0xB8;
        lightVisibilityOffset           = lightOffset + lightVisibilityPadding;
        lightVisibilitySize             = 0x1C;
        // Camera
        cameraCount                     = ReadUInt(startOffset + 0x124);
        cameraOffset                    = ReadUInt(startOffset + 0x128);
        cameraSize                      = 0x7C;
        cameraFovPadding                = 0x04;
        cameraFarclipPadding            = 0x08;
        cameraNearclipPadding           = 0x0C;
        cameraTranslationPosPadding     = 0x10;
        cameraTranslationPosOffset      = cameraOffset + cameraTranslationPosPadding;
        cameraTranslationPosSize        = 0x1C;
        cameraPositionPadding           = 0x2C;
        cameraTranslationTarPadding     = 0x38;
        cameraTranslationTarOffset      = cameraOffset + cameraTranslationTarPadding;
        cameraTranslationTarSize        = 0x1C;
        cameraTargetPadding             = 0x54;
        cameraRollPadding               = 0x60;
        cameraRollOffset                = cameraOffset + cameraRollPadding;
        cameraRollSize                  = 0x1C;
        // Ribbon
        ribbonCount                     = ReadUInt(startOffset + 0x134);
        ribbonOffset                    = ReadUInt(startOffset + 0x138);
        ribbonSize                      = 0xDC;
        ribbonPositionPadding           = 0x08;
        ribbonColorPadding              = 0x24;
        ribbonColorOffset               = ribbonOffset + ribbonColorPadding;
        ribbonColorSize                 = 0x1C;
        ribbonAlphaPadding              = 0x40;
        ribbonAlphaOffset               = ribbonOffset + ribbonAlphaPadding;
        ribbonAlphaSize                 = 0x1C;
        ribbonHeightAbovePadding        = 0x5C;
        ribbonHeightAboveOffset         = ribbonOffset + ribbonHeightAbovePadding;
        ribbonHeightAboveSize           = 0x1C;
        ribbonHeightBelowPadding        = 0x78;
        ribbonHeightBelowOffset         = ribbonOffset + ribbonHeightBelowPadding;
        ribbonHeightBelowSize           = 0x1C;
        ribbonEdgeRatePadding           = 0x94;
        ribbonEdgeLifespanPadding       = 0x98;
        ribbonGravityPadding            = 0x9C;
        ribbonVisibilityPadding         = 0xC0;
        ribbonVisibilityOffset          = ribbonOffset + ribbonVisibilityPadding;
        ribbonVisibilitySize            = 0x1C;
        // Particle
        particleCount                   = ReadUInt(startOffset + 0x13C);
        particleOffset                  = ReadUInt(startOffset + 0x140);
        particleSize                    = 0x1F8;
        particlePositionPadding         = 0x08;
        particleEmissionSpeedPadding    = 0x34;
        particleEmissionSpeedOffset     = particleOffset + particleEmissionSpeedPadding;
        particleEmissionSpeedSize       = 0x1C;
        particleSpeedPadding            = 0x50;
        particleSpeedOffset             = particleOffset + particleSpeedPadding;
        particleSpeedSize               = 0x1C;
        particleVerticalPadding         = 0x6C;
        particleVerticalOffset          = particleOffset + particleVerticalPadding;
        particleVerticalSize            = 0x1C;
        particleHorizontalPadding       = 0x88;
        particleHorizontalOffset        = particleOffset + particleHorizontalPadding;
        particleHorizontalSize          = 0x1C;
        particleGravityPadding          = 0xA4;
        particleGravityOffset           = particleOffset + particleGravityPadding;
        particleGravitySize             = 0x1C;
        particleLifespanPadding         = 0xC0;
        particleLifespanOffset          = particleOffset + particleLifespanPadding;
        particleLifespanSize            = 0x1C;
        particleEmissionRatePadding     = 0xDC;
        particleEmissionRateOffset      = particleOffset + particleEmissionRateOffset;
        particleEmissionRateSize        = 0x1C;
        particleEmissionLengthPadding   = 0xF8;
        particleEmissionLengthOffset    = particleOffset + particleEmissionLengthPadding;
        particleEmissionLengthSize      = 0x1C;
        particleEmissionWidthPadding    = 0x114;
        particleEmissionWidthOffset     = particleOffset + particleEmissionWidthPadding;
        particleEmissionWidthSize       = 0x1C;
        particleSourcePadding           = 0x130;
        particleSourceOffset            = particleOffset + particleSourcePadding;
        particleSourceSize              = 0x1C;
        particleMidpointPadding         = 0x14C;
        particleColorPadding            = 0x150;
        particleScalePadding            = 0x15C;
        particleTailLengthPadding       = 0x17C;
        particleTwinkleSpeedPadding     = 0x180;
        particleTwinklePercentPadding   = 0x184;
        particleTwinkleScalePadding     = 0x188;
        particleBurstPadding            = 0x190;
        particleDragPadding             = 0x194;
        particleSpinPadding             = 0x198;
        particleTumbleMinPadding        = 0x19C;
        particleTumbleMaxPadding        = 0x1A8;
        particleWindVectorPadding       = 0x1B4;
        particleWindTimePadding         = 0x1C0;
        particleFollowSpeed1Padding     = 0x1C4;
        particleFollowScale1Padding     = 0x1C8;
        particleFollowSpeed2Padding     = 0x1CC;
        particleFollowScale2Padding     = 0x1D0;
        particleEnabledPadding          = 0x1DC;
        particleEnabledOffset           = particleOffset + particleEnabledPadding;
        particleEnabledSize             = 0x1C;
    }
    if (version == 264)               
    {
        Printf("File Version [%u] - Set to Wrath of the Lich King mode\n", version);
        // Expansion
        expansion                       = 3; // Wrath of the Lich King
        // Sequence
        sequenceCount                   = ReadUInt(startOffset + 0x1C);
        sequenceOffset                  = ReadUInt(startOffset + 0x20);
        sequenceSize                    = 0x40;
        sequencePositionPadding         = 0x20;
        sequenceIdPadding               = 0x00;
        sequenceSubPadding              = 0x02;
        sequenceFlagPadding             = 0x0C;
        // Bone
        boneCount                       = ReadUInt(startOffset + 0x2C);
        boneOffset                      = ReadUInt(startOffset + 0x30);
        boneSize                        = 0x58;
        boneTranslationPadding          = 0x10;
        boneTranslationOffset           = boneOffset + boneTranslationPadding;
        boneTranslationSize             = 0x14;
        boneRotationPadding             = 0x24;
        boneRotationOffset              = boneOffset + boneRotationPadding;
        boneRotationSize                = 0x14;
        boneScalingPadding              = 0x38;
        boneScalingOffset               = boneOffset + boneScalingPadding;
        boneScalingSize                 = 0x14;
        bonePivotPadding                = 0x4C;
        // Vertice
        verticeCount                    = ReadUInt(startOffset + 0x3C);
        verticeOffset                   = ReadUInt(startOffset + 0x40);
        verticeSize                     = 0x30;
        verticePositionPadding          = 0x00;
        // Color
        colorCount                      = ReadUInt(startOffset + 0x48);
        colorOffset                     = ReadUInt(startOffset + 0x4C);
        colorSize                       = 0x28;
        colorColorOffset                = colorOffset + 0x00;
        colorColorSize                  = 0x14;
        colorColorPadding               = 0x00;
        colorAlphaOffset                = colorOffset + 0x14;
        colorAlphaSize                  = 0x14;
        colorAlphaPadding               = 0x14;
        // Weight
        weightCount                     = ReadUInt(startOffset + 0x58);
        weightOffset                    = ReadUInt(startOffset + 0x5C);
        weightSize                      = 0x14;
        // Transform
        transformCount                  = ReadUInt(startOffset + 0x60);
        transformOffset                 = ReadUInt(startOffset + 0x64);
        transformSize                   = 0x3C;
        transformTranslationPadding     = 0x00;
        transformTranslationOffset      = transformOffset + transformTranslationPadding;
        transformTranslationSize        = 0x14;
        transformRotationPadding        = 0x14;
        transformRotationOffset         = transformOffset + transformRotationPadding;
        transformRotationSize           = 0x14;
        transformScalingPadding         = 0x28;
        transformScalingOffset          = transformOffset + transformScalingPadding;
        transformScalingSize            = 0x14;
        // Bounding
        boundingOffset                  = 0xA0;
        boundingSize                    = 0x38;
        boundingRadius                  = 0x18;
        // Collision
        collisionBoxPadding             = 0x1C;
        collisionRadius                 = 0x34;
        collisionCount                  = ReadUInt(startOffset + 0xE0);
        collisionOffset                 = ReadUInt(startOffset + 0xE4);
        collisionSize                   = 0x0C;
        // Normal
        normalCount                     = ReadUInt(startOffset + 0xE8);
        normalOffset                    = ReadUInt(startOffset + 0xEC);
        normalSize                      = 0x0C;
        // Attachment
        attachmentCount                 = ReadUInt(startOffset + 0xF0);
        attachmentOffset                = ReadUInt(startOffset + 0xF4);
        attachmentSize                  = 0x28;
        attachmentPositionPadding       = 0x08;
        // Event
        eventCount                      = ReadUInt(startOffset + 0x100);
        eventOffset                     = ReadUInt(startOffset + 0x104);
        eventSize                       = 0x24;
        eventPositionPadding            = 0x0C;
        // Light
        lightCount                      = ReadUInt(startOffset + 0x108);
        lightOffset                     = ReadUInt(startOffset + 0x10C);
        lightSize                       = 0x9C;
        lightPositionPadding            = 0x04;
        lightAmbientColorPadding        = 0x10;
        lightAmbientColorOffset         = lightOffset + lightAmbientColorPadding;
        lightAmbientColorSize           = 0x14;
        lightAmbientIntensityPadding    = 0x24;
        lightAmbientIntensityOffset     = lightOffset + lightAmbientIntensityPadding;
        lightAmbientIntensitySize       = 0x14;
        lightDiffuseColorPadding        = 0x38;
        lightDiffuseColorOffset         = lightOffset + lightDiffuseColorPadding;
        lightDiffuseColorSize           = 0x14;
        lightDiffuseIntensityPadding    = 0x4C;
        lightDiffuseIntensityOffset     = lightOffset + lightDiffuseIntensityPadding;
        lightDiffuseIntensitySize       = 0x14;
        lightAttenuationStartPadding    = 0x60;
        lightAttenuationStartOffset     = lightOffset + lightAttenuationStartPadding;
        lightAttenuationStartSize       = 0x14;
        lightAttenuationEndPadding      = 0x74;
        lightAttenuationEndOffset       = lightOffset + lightAttenuationEndPadding;
        lightAttenuationEndSize         = 0x14;
        lightVisibilityPadding          = 0x88;
        lightVisibilityOffset           = lightOffset + lightVisibilityPadding;
        lightVisibilitySize             = 0x14;
        // Camera
        cameraCount                     = ReadUInt(startOffset + 0x110);
        cameraOffset                    = ReadUInt(startOffset + 0x114);
        cameraSize                      = 0x64;
        cameraFovPadding                = 0x04;
        cameraFarclipPadding            = 0x08;
        cameraNearclipPadding           = 0x0C;
        cameraTranslationPosPadding     = 0x10;
        cameraTranslationPosOffset      = cameraOffset + cameraTranslationPosPadding;
        cameraTranslationPosSize        = 0x14;
        cameraPositionPadding           = 0x24;
        cameraTranslationTarPadding     = 0x30;
        cameraTranslationTarOffset      = cameraOffset + cameraTranslationTarPadding;
        cameraTranslationTarSize        = 0x14;
        cameraTargetPadding             = 0x44;
        cameraRollPadding               = 0x50;
        cameraRollOffset                = cameraOffset + cameraRollPadding;
        cameraRollSize                  = 0x14;
        // Ribbon
        ribbonCount                     = ReadUInt(startOffset + 0x120);
        ribbonOffset                    = ReadUInt(startOffset + 0x124);
        ribbonSize                      = 0xB0;
        ribbonPositionPadding           = 0x08;
        ribbonColorPadding              = 0x24;
        ribbonColorOffset               = ribbonOffset + ribbonColorPadding;
        ribbonColorSize                 = 0x14;
        ribbonAlphaPadding              = 0x38;
        ribbonAlphaOffset               = ribbonOffset + ribbonAlphaPadding;
        ribbonAlphaSize                 = 0x14;
        ribbonHeightAbovePadding        = 0x4C;
        ribbonHeightAboveOffset         = ribbonOffset + ribbonHeightAbovePadding;
        ribbonHeightAboveSize           = 0x14;
        ribbonHeightBelowPadding        = 0x60;
        ribbonHeightBelowOffset         = ribbonOffset + ribbonHeightBelowPadding;
        ribbonHeightBelowSize           = 0x14;
        ribbonEdgeRatePadding           = 0x74;
        ribbonEdgeLifespanPadding       = 0x78;
        ribbonGravityPadding            = 0x7C;
        ribbonVisibilityPadding         = 0x98;
        ribbonVisibilityOffset          = ribbonOffset + ribbonVisibilityPadding;
        ribbonVisibilitySize            = 0x14;
        // Particle
        particleCount                   = ReadUInt(startOffset + 0x128);
        particleOffset                  = ReadUInt(startOffset + 0x12C);
        particleSize                    = 0x1DC;
        particlePositionPadding         = 0x08;
        particleEmissionSpeedPadding    = 0x34;
        particleEmissionSpeedOffset     = particleOffset + particleEmissionSpeedPadding;
        particleEmissionSpeedSize       = 0x14;
        particleSpeedPadding            = 0x48;
        particleSpeedOffset             = particleOffset + particleSpeedPadding;
        particleSpeedSize               = 0x14;
        particleVerticalPadding         = 0x5C;
        particleVerticalOffset          = particleOffset + particleVerticalPadding;
        particleVerticalSize            = 0x14;
        particleHorizontalPadding       = 0x70;
        particleHorizontalOffset        = particleOffset + particleHorizontalPadding;
        particleHorizontalSize          = 0x14;
        particleGravityPadding          = 0x84;
        particleGravityOffset           = particleOffset + particleGravityPadding;
        particleGravitySize             = 0x14;
        particleLifespanPadding         = 0x98;
        particleLifespanOffset          = particleOffset + particleLifespanPadding;
        particleLifespanSize            = 0x14;
        particleLifespanVaryPadding     = 0xAC;
        particleEmissionRatePadding     = 0xB0;
        particleEmissionRateOffset      = particleOffset + particleEmissionRatePadding;
        particleEmissionRateSize        = 0x14;
        particleEmissionRateVaryPadding = 0xC4;
        particleEmissionLengthPadding   = 0xC8;
        particleEmissionLengthOffset    = particleOffset + particleEmissionLengthPadding;
        particleEmissionLengthSize      = 0x14;
        particleEmissionWidthPadding    = 0xDC;
        particleEmissionWidthOffset     = particleOffset + particleEmissionWidthPadding;
        particleEmissionWidthSize       = 0x14;
        particleSourcePadding           = 0xF0;
        particleSourceOffset            = particleOffset + particleSourcePadding;
        particleSourceSize              = 0x14;
        particleColorPadding            = 0x104;
        particleColorOffset             = particleOffset + particleColorPadding;
        particleColorSize               = 0x10;
        particleAlphaPadding            = 0x114;
        particleAlphaOffset             = particleOffset + particleAlphaPadding;
        particleAlphaSize               = 0x10;
        particleScalePadding            = 0x124;
        particleScaleOffset             = particleOffset + particleScalePadding;
        particleScaleSize               = 0x10;
        particleScaleVaryPadding        = 0x134;
        particleTailLengthPadding       = 0x15C;
        particleTwinkleSpeedPadding     = 0x160;
        particleTwinklePercentPadding   = 0x164;
        particleTwinkleScalePadding     = 0x168;
        particleBurstPadding            = 0x170;
        particleDragPadding             = 0x174;
        particleBaseSpinPadding         = 0x178;
        particleBaseSpinVaryPadding     = 0x17C;
        particleSpinPadding             = 0x180;
        particleSpinVaryPadding         = 0x184;
        particleTumbleMinPadding        = 0x188;
        particleTumbleMaxPadding        = 0x194;
        particleWindVectorPadding       = 0x1A0;
        particleWindTimePadding         = 0x1AC;
        particleFollowSpeed1Padding     = 0x1B0;
        particleFollowScale1Padding     = 0x1B4;
        particleFollowSpeed2Padding     = 0x1B8;
        particleFollowScale2Padding     = 0x1Bc;
        particleEnabledPadding          = 0x1C8;
        particleEnabledOffset           = particleOffset + particleEnabledPadding;
        particleEnabledSize             = 0x14;
    }
    if (version >= 265 && version < 272)
    {
        Printf("File Version [%u] - Set to Cataclysm mode\n", version);
        // Expansion
        expansion                       = 4; // Cataclysm
        // Sequence
        sequenceCount                   = ReadUInt(startOffset + 0x1C);
        sequenceOffset                  = ReadUInt(startOffset + 0x20);
        sequenceSize                    = 0x40;
        sequencePositionPadding         = 0x20;
        sequenceIdPadding               = 0x00;
        sequenceSubPadding              = 0x02;
        sequenceFlagPadding             = 0x0C;
        // Bone
        boneCount                       = ReadUInt(startOffset + 0x2C);
        boneOffset                      = ReadUInt(startOffset + 0x30);
        boneSize                        = 0x58;
        boneTranslationPadding          = 0x10;
        boneTranslationOffset           = boneOffset + boneTranslationPadding;
        boneTranslationSize             = 0x14;
        boneRotationPadding             = 0x24;
        boneRotationOffset              = boneOffset + boneRotationPadding;
        boneRotationSize                = 0x14;
        boneScalingPadding              = 0x38;
        boneScalingOffset               = boneOffset + boneScalingPadding;
        boneScalingSize                 = 0x14;
        bonePivotPadding                = 0x4C;
        // Vertice
        verticeCount                    = ReadUInt(startOffset + 0x3C);
        verticeOffset                   = ReadUInt(startOffset + 0x40);
        verticeSize                     = 0x30;
        verticePositionPadding          = 0x00;
        // Color
        colorCount                      = ReadUInt(startOffset + 0x48);
        colorOffset                     = ReadUInt(startOffset + 0x4C);
        colorSize                       = 0x28;
        colorColorOffset                = colorOffset + 0x00;
        colorColorSize                  = 0x14;
        colorColorPadding               = 0x00;
        colorAlphaOffset                = colorOffset + 0x14;
        colorAlphaSize                  = 0x14;
        colorAlphaPadding               = 0x14;
        // Weight
        weightCount                     = ReadUInt(startOffset + 0x58);
        weightOffset                    = ReadUInt(startOffset + 0x5C);
        weightSize                      = 0x14;
        // Transform
        transformCount                  = ReadUInt(startOffset + 0x60);
        transformOffset                 = ReadUInt(startOffset + 0x64);
        transformSize                   = 0x3C;
        transformTranslationPadding     = 0x00;
        transformTranslationOffset      = transformOffset + transformTranslationPadding;
        transformTranslationSize        = 0x14;
        transformRotationPadding        = 0x14;
        transformRotationOffset         = transformOffset + transformRotationPadding;
        transformRotationSize           = 0x14;
        transformScalingPadding         = 0x28;
        transformScalingOffset          = transformOffset + transformScalingPadding;
        transformScalingSize            = 0x14;
        // Bounding
        boundingOffset                  = 0xA0;
        boundingSize                    = 0x38;
        boundingRadius                  = 0x18;
        // Collision
        collisionBoxPadding             = 0x1C;
        collisionRadius                 = 0x34;
        collisionCount                  = ReadUInt(startOffset + 0xE0);
        collisionOffset                 = ReadUInt(startOffset + 0xE4);
        collisionSize                   = 0x0C;
        // Normal
        normalCount                     = ReadUInt(startOffset + 0xE8);
        normalOffset                    = ReadUInt(startOffset + 0xEC);
        normalSize                      = 0x0C;
        // Attachment
        attachmentCount                 = ReadUInt(startOffset + 0xF0);
        attachmentOffset                = ReadUInt(startOffset + 0xF4);
        attachmentSize                  = 0x28;
        attachmentPositionPadding       = 0x08;
        // Event
        eventCount                      = ReadUInt(startOffset + 0x100);
        eventOffset                     = ReadUInt(startOffset + 0x104);
        eventSize                       = 0x24;
        eventPositionPadding            = 0x0C;
        // Light
        lightCount                      = ReadUInt(startOffset + 0x108);
        lightOffset                     = ReadUInt(startOffset + 0x10C);
        lightSize                       = 0x9C;
        lightPositionPadding            = 0x04;
        lightAmbientColorPadding        = 0x10;
        lightAmbientColorOffset         = lightOffset + lightAmbientColorPadding;
        lightAmbientColorSize           = 0x14;
        lightAmbientIntensityPadding    = 0x24;
        lightAmbientIntensityOffset     = lightOffset + lightAmbientIntensityPadding;
        lightAmbientIntensitySize       = 0x14;
        lightDiffuseColorPadding        = 0x38;
        lightDiffuseColorOffset         = lightOffset + LightDiffuseColorPadding;
        lightDiffuseColorSize           = 0x14;
        lightDiffuseIntensityPadding    = 0x4C;
        lightDiffuseIntensityOffset     = lightOffset + lightDiffuseIntensityPadding;
        lightDiffuseIntensitySize       = 0x14;
        lightAttenuationStartPadding    = 0x60;
        lightAttenuationStartOffset     = lightOffset + lightAttenuationStartPadding;
        lightAttenuationStartSize       = 0x14;
        lightAttenuationEndPadding      = 0x74;
        lightAttenuationEndOffset       = lightOffset + lightAttenuationEndPadding;
        lightAttenuationEndSize         = 0x14;
        lightVisibilityPadding          = 0x88;
        lightVisibilityOffset           = lightOffset + lightVisibilityPadding;
        lightVisibilitySize             = 0x14;
        // Camera
        cameraCount                     = ReadUInt(startOffset + 0x110);
        cameraOffset                    = ReadUInt(startOffset + 0x114);
        cameraSize                      = 0x64;
        cameraFovPadding                = 0x04;
        cameraFarclipPadding            = 0x08;
        cameraNearclipPadding           = 0x0C;
        cameraTranslationPosPadding     = 0x10;
        cameraTranslationPosOffset      = cameraOffset + cameraTranslationPosPadding;
        cameraTranslationPosSize        = 0x14;
        cameraPositionPadding           = 0x24;
        cameraTranslationTarPadding     = 0x30;
        cameraTranslationTarOffset      = cameraOffset + cameraTranslationTarPadding;
        cameraTranslationTarSize        = 0x14;
        cameraTargetPadding             = 0x44;
        cameraRollPadding               = 0x50;
        cameraRollOffset                = cameraOffset + cameraRollPadding;
        cameraRollSize                  = 0x14;
        // Ribbon
        ribbonCount                     = ReadUInt(startOffset + 0x120);
        ribbonOffset                    = ReadUInt(startOffset + 0x124);
        ribbonSize                      = 0xB0;
        ribbonPositionPadding           = 0x08;
        ribbonColorPadding              = 0x24;
        ribbonColorOffset               = ribbonOffset + ribbonColorPadding;
        ribbonColorSize                 = 0x14;
        ribbonAlphaPadding              = 0x38;
        ribbonAlphaOffset               = ribbonOffset + ribbonAlphaPadding;
        ribbonAlphaSize                 = 0x14;
        ribbonHeightAbovePadding        = 0x4C;
        ribbonHeightAboveOffset         = ribbonOffset + ribbonHeightAbovePadding;
        ribbonHeightAboveSize           = 0x14;
        ribbonHeightBelowPadding        = 0x60;
        ribbonHeightBelowOffset         = ribbonOffset + ribbonHeightBelowPadding;
        ribbonHeightBelowSize           = 0x14;
        ribbonEdgeRatePadding           = 0x74;
        ribbonEdgeLifespanPadding       = 0x78;
        ribbonGravityPadding            = 0x7C;
        ribbonVisibilityPadding         = 0x98;
        ribbonVisibilityOffset          = ribbonOffset + ribbonVisibilityPadding;
        ribbonVisibilitySize            = 0x14;
        // Particle
        particleCount                   = ReadUInt(startOffset + 0x128);
        particleOffset                  = ReadUInt(startOffset + 0x12C);
        particleSize                    = 0x1DC;
        particlePositionPadding         = 0x08;
        particleEmissionSpeedPadding    = 0x34;
        particleEmissionSpeedOffset     = particleOffset + particleEmissionSpeedPadding;
        particleEmissionSpeedSize       = 0x14;
        particleSpeedPadding            = 0x48;
        particleSpeedOffset             = particleOffset + particleSpeedPadding;
        particleSpeedSize               = 0x14;
        particleVerticalPadding         = 0x5C;
        particleVerticalOffset          = particleOffset + particleVerticalPadding;
        particleVerticalSize            = 0x14;
        particleHorizontalPadding       = 0x70;
        particleHorizontalOffset        = particleOffset + particleHorizontalPadding;
        particleHorizontalSize          = 0x14;
        particleGravityPadding          = 0x84;
        particleGravityOffset           = particleOffset + particleGravityPadding;
        particleGravitySize             = 0x14;
        particleLifespanPadding         = 0x98;
        particleLifespanOffset          = particleOffset + particleLifespanPadding;
        particleLifespanSize            = 0x14;
        particleLifespanVaryPadding     = 0xAC;
        particleEmissionRatePadding     = 0xB0;
        particleEmissionRateOffset      = particleOffset + particleEmissionRatePadding;
        particleEmissionRateSize        = 0x14;
        particleEmissionRateVaryPadding = 0xC4;
        particleEmissionLengthPadding   = 0xC8;
        particleEmissionLengthOffset    = particleOffset + particleEmissionLengthPadding;
        particleEmissionLengthSize      = 0x14;
        particleEmissionWidthPadding    = 0xDC;
        particleEmissionWidthOffset     = particleOffset + particleEmissionWidthPadding;
        particleEmissionWidthSize       = 0x14;
        particleSourcePadding           = 0xF0;
        particleSourceOffset            = particleOffset + particleSourcePadding;
        particleSourceSize              = 0x14;
        particleColorPadding            = 0x104;
        particleColorOffset             = particleOffset + particleColorPadding;
        particleColorSize               = 0x10;
        particleAlphaPadding            = 0x114;
        particleAlphaOffset             = particleOffset + particleAlphaPadding;
        particleAlphaSize               = 0x10;
        particleScalePadding            = 0x124;
        particleScaleOffset             = particleOffset + particleScalePadding;
        particleScaleSize               = 0x10;
        particleScaleVaryPadding        = 0x134;
        particleTailLengthPadding       = 0x15C;
        particleTwinkleSpeedPadding     = 0x160;
        particleTwinklePercentPadding   = 0x164;
        particleTwinkleScalePadding     = 0x168;
        particleBurstPadding            = 0x170;
        particleDragPadding             = 0x174;
        particleBaseSpinPadding         = 0x178;
        particleBaseSpinVaryPadding     = 0x17C;
        particleSpinPadding             = 0x180;
        particleSpinVaryPadding         = 0x184;
        particleTumbleMinPadding        = 0x188;
        particleTumbleMaxPadding        = 0x194;
        particleWindVectorPadding       = 0x1A0;
        particleWindTimePadding         = 0x1AC;
        particleFollowSpeed1Padding     = 0x1B0;
        particleFollowScale1Padding     = 0x1B4;
        particleFollowSpeed2Padding     = 0x1B8;
        particleFollowScale2Padding     = 0x1Bc;
        particleEnabledPadding          = 0x1C8;
        particleEnabledOffset           = particleOffset + particleEnabledPadding;
        particleEnabledSize             = 0x14;
    }
    if (version == 272)
    {
        Printf("File Version [%u] - Set to Mists of Pandaria mode\n", version);
        // Expansion
        expansion                       = 5; // Mists of Pandaria
        // Sequence
        sequenceCount                   = ReadUInt(startOffset + 0x1C);
        sequenceOffset                  = ReadUInt(startOffset + 0x20);
        sequenceSize                    = 0x40;
        sequencePositionPadding         = 0x20;
        sequenceIdPadding               = 0x00;
        sequenceSubPadding              = 0x02;
        sequenceFlagPadding             = 0x0C;
        // Bone
        boneCount                       = ReadUInt(startOffset + 0x2C);
        boneOffset                      = ReadUInt(startOffset + 0x30);
        boneSize                        = 0x58;
        boneTranslationPadding          = 0x10;
        boneTranslationOffset           = boneOffset + boneTranslationPadding;
        boneTranslationSize             = 0x14;
        boneRotationPadding             = 0x24;
        boneRotationOffset              = boneOffset + boneRotationPadding;
        boneRotationSize                = 0x14;
        boneScalingPadding              = 0x38;
        boneScalingOffset               = boneOffset + boneScalingPadding;
        boneScalingSize                 = 0x14;
        bonePivotPadding                = 0x4C;
        // Vertice
        verticeCount                    = ReadUInt(startOffset + 0x3C);
        verticeOffset                   = ReadUInt(startOffset + 0x40);
        verticeSize                     = 0x30;
        verticePositionPadding          = 0x00;
        // Color
        colorCount                      = ReadUInt(startOffset + 0x48);
        colorOffset                     = ReadUInt(startOffset + 0x4C);
        colorSize                       = 0x28;
        colorColorOffset                = colorOffset + 0x00;
        colorColorSize                  = 0x14;
        colorColorPadding               = 0x00;
        colorAlphaOffset                = colorOffset + 0x14;
        colorAlphaSize                  = 0x14;
        colorAlphaPadding               = 0x14;
        // Weight
        weightCount                     = ReadUInt(startOffset + 0x58);
        weightOffset                    = ReadUInt(startOffset + 0x5C);
        weightSize                      = 0x14;
        // Transform
        transformCount                  = ReadUInt(startOffset + 0x60);
        transformOffset                 = ReadUInt(startOffset + 0x64);
        transformSize                   = 0x3C;
        transformTranslationPadding     = 0x00;
        transformTranslationOffset      = transformOffset + transformTranslationPadding;
        transformTranslationSize        = 0x14;
        transformRotationPadding        = 0x14;
        transformRotationOffset         = transformOffset + transformRotationPadding;
        transformRotationSize           = 0x14;
        transformScalingPadding         = 0x28;
        transformScalingOffset          = transformOffset + transformScalingPadding;
        transformScalingSize            = 0x14;
        // Bounding
        boundingOffset                  = 0xA0;
        boundingSize                    = 0x38;
        boundingRadius                  = 0x18;
        // Collision
        collisionBoxPadding             = 0x1C;
        collisionRadius                 = 0x34;
        collisionCount                  = ReadUInt(startOffset + 0xE0);
        collisionOffset                 = ReadUInt(startOffset + 0xE4);
        collisionSize                   = 0x0C;
        // Normal
        normalCount                     = ReadUInt(startOffset + 0xE8);
        normalOffset                    = ReadUInt(startOffset + 0xEC);
        normalSize                      = 0x0C;
        // Attachment
        attachmentCount                 = ReadUInt(startOffset + 0xF0);
        attachmentOffset                = ReadUInt(startOffset + 0xF4);
        attachmentSize                  = 0x28;
        attachmentPositionPadding       = 0x08;
        // Event
        eventCount                      = ReadUInt(startOffset + 0x100);
        eventOffset                     = ReadUInt(startOffset + 0x104);
        eventSize                       = 0x24;
        eventPositionPadding            = 0x0C;
        // Light
        lightCount                      = ReadUInt(startOffset + 0x108);
        lightOffset                     = ReadUInt(startOffset + 0x10C);
        lightSize                       = 0x9C;
        lightPositionPadding            = 0x04;
        lightAmbientColorPadding        = 0x10;
        lightAmbientColorOffset         = lightOffset + lightAmbientColorPadding;
        lightAmbientColorSize           = 0x14;
        lightAmbientIntensityPadding    = 0x24;
        lightAmbientIntensityOffset     = lightOffset + lightAmbientIntensityPadding;
        lightAmbientIntensitySize       = 0x14;
        lightDiffuseColorPadding        = 0x38;
        lightDiffuseColorOffset         = lightOffset + LightDiffuseColorPadding;
        lightDiffuseColorSize           = 0x14;
        lightDiffuseIntensityPadding    = 0x4C;
        lightDiffuseIntensityOffset     = lightOffset + lightDiffuseIntensityPadding;
        lightDiffuseIntensitySize       = 0x14;
        lightAttenuationStartPadding    = 0x60;
        lightAttenuationStartOffset     = lightOffset + lightAttenuationStartPadding;
        lightAttenuationStartSize       = 0x14;
        lightAttenuationEndPadding      = 0x74;
        lightAttenuationEndOffset       = lightOffset + lightAttenuationEndPadding;
        lightAttenuationEndSize         = 0x14;
        lightVisibilityPadding          = 0x88;
        lightVisibilityOffset           = lightOffset + lightVisibilityPadding;
        lightVisibilitySize             = 0x14;
        // Camera
        cameraCount                     = ReadUInt(startOffset + 0x110);
        cameraOffset                    = ReadUInt(startOffset + 0x114);
        cameraSize                      = 0x64;
        cameraFovPadding                = 0x04;
        cameraFarclipPadding            = 0x08;
        cameraNearclipPadding           = 0x0C;
        cameraTranslationPosPadding     = 0x10;
        cameraTranslationPosOffset      = cameraOffset + cameraTranslationPosPadding;
        cameraTranslationPosSize        = 0x14;
        cameraPositionPadding           = 0x24;
        cameraTranslationTarPadding     = 0x30;
        cameraTranslationTarOffset      = cameraOffset + cameraTranslationTarPadding;
        cameraTranslationTarSize        = 0x14;
        cameraTargetPadding             = 0x44;
        cameraRollPadding               = 0x50;
        cameraRollOffset                = cameraOffset + cameraRollPadding;
        cameraRollSize                  = 0x14;
        // Ribbon
        ribbonCount                     = ReadUInt(startOffset + 0x120);
        ribbonOffset                    = ReadUInt(startOffset + 0x124);
        ribbonSize                      = 0xB0;
        ribbonPositionPadding           = 0x08;
        ribbonColorPadding              = 0x24;
        ribbonColorOffset               = ribbonOffset + ribbonColorPadding;
        ribbonColorSize                 = 0x14;
        ribbonAlphaPadding              = 0x38;
        ribbonAlphaOffset               = ribbonOffset + ribbonAlphaPadding;
        ribbonAlphaSize                 = 0x14;
        ribbonHeightAbovePadding        = 0x4C;
        ribbonHeightAboveOffset         = ribbonOffset + ribbonHeightAbovePadding;
        ribbonHeightAboveSize           = 0x14;
        ribbonHeightBelowPadding        = 0x60;
        ribbonHeightBelowOffset         = ribbonOffset + ribbonHeightBelowPadding;
        ribbonHeightBelowSize           = 0x14;
        ribbonEdgeRatePadding           = 0x74;
        ribbonEdgeLifespanPadding       = 0x78;
        ribbonGravityPadding            = 0x7C;
        ribbonVisibilityPadding         = 0x98;
        ribbonVisibilityOffset          = ribbonOffset + ribbonVisibilityPadding;
        ribbonVisibilitySize            = 0x14;
        // Particle
        particleCount                   = ReadUInt(startOffset + 0x128);
        particleOffset                  = ReadUInt(startOffset + 0x12C);
        particleSize                    = 0x1DC;
        particlePositionPadding         = 0x08;
        particleEmissionSpeedPadding    = 0x34;
        particleEmissionSpeedOffset     = particleOffset + particleEmissionSpeedPadding;
        particleEmissionSpeedSize       = 0x14;
        particleSpeedPadding            = 0x48;
        particleSpeedOffset             = particleOffset + particleSpeedPadding;
        particleSpeedSize               = 0x14;
        particleVerticalPadding         = 0x5C;
        particleVerticalOffset          = particleOffset + particleVerticalPadding;
        particleVerticalSize            = 0x14;
        particleHorizontalPadding       = 0x70;
        particleHorizontalOffset        = particleOffset + particleHorizontalPadding;
        particleHorizontalSize          = 0x14;
        particleGravityPadding          = 0x84;
        particleGravityOffset           = particleOffset + particleGravityPadding;
        particleGravitySize             = 0x14;
        particleLifespanPadding         = 0x98;
        particleLifespanOffset          = particleOffset + particleLifespanPadding;
        particleLifespanSize            = 0x14;
        particleLifespanVaryPadding     = 0xAC;
        particleEmissionRatePadding     = 0xB0;
        particleEmissionRateOffset      = particleOffset + particleEmissionRatePadding;
        particleEmissionRateSize        = 0x14;
        particleEmissionRateVaryPadding = 0xC4;
        particleEmissionLengthPadding   = 0xC8;
        particleEmissionLengthOffset    = particleOffset + particleEmissionLengthPadding;
        particleEmissionLengthSize      = 0x14;
        particleEmissionWidthPadding    = 0xDC;
        particleEmissionWidthOffset     = particleOffset + particleEmissionWidthPadding;
        particleEmissionWidthSize       = 0x14;
        particleSourcePadding           = 0xF0;
        particleSourceOffset            = particleOffset + particleSourcePadding;
        particleSourceSize              = 0x14;
        particleColorPadding            = 0x104;
        particleColorOffset             = particleOffset + particleColorPadding;
        particleColorSize               = 0x10;
        particleAlphaPadding            = 0x114;
        particleAlphaOffset             = particleOffset + particleAlphaPadding;
        particleAlphaSize               = 0x10;
        particleScalePadding            = 0x124;
        particleScaleOffset             = particleOffset + particleScalePadding;
        particleScaleSize               = 0x10;
        particleScaleVaryPadding        = 0x134;
        particleTailLengthPadding       = 0x15C;
        particleTwinkleSpeedPadding     = 0x160;
        particleTwinklePercentPadding   = 0x164;
        particleTwinkleScalePadding     = 0x168;
        particleBurstPadding            = 0x170;
        particleDragPadding             = 0x174;
        particleBaseSpinPadding         = 0x178;
        particleBaseSpinVaryPadding     = 0x17C;
        particleSpinPadding             = 0x180;
        particleSpinVaryPadding         = 0x184;
        particleTumbleMinPadding        = 0x188;
        particleTumbleMaxPadding        = 0x194;
        particleWindVectorPadding       = 0x1A0;
        particleWindTimePadding         = 0x1AC;
        particleFollowSpeed1Padding     = 0x1B0;
        particleFollowScale1Padding     = 0x1B4;
        particleFollowSpeed2Padding     = 0x1B8;
        particleFollowScale2Padding     = 0x1Bc;
        particleEnabledPadding          = 0x1C8;
        particleEnabledOffset           = particleOffset + particleEnabledPadding;
        particleEnabledSize             = 0x14;
    }
    if (version >= 273)
    {
        Printf("File Version [%u] - Set to Retail mode\n", version);
        // Expansion
        expansion                       = 6; // Retail
        // Sequence
        sequenceCount                   = ReadUInt(startOffset + 0x1C);
        sequenceOffset                  = ReadUInt(startOffset + 0x20);
        sequenceSize                    = 0x40;
        sequencePositionPadding         = 0x20;
        sequenceIdPadding               = 0x00;
        sequenceSubPadding              = 0x02;
        sequenceFlagPadding             = 0x0C;
        // Bone
        boneCount                       = ReadUInt(startOffset + 0x2C);
        boneOffset                      = ReadUInt(startOffset + 0x30);
        boneSize                        = 0x58;
        boneTranslationPadding          = 0x10;
        boneTranslationOffset           = boneOffset + boneTranslationPadding;
        boneTranslationSize             = 0x14;
        boneRotationPadding             = 0x24;
        boneRotationOffset              = boneOffset + boneRotationPadding;
        boneRotationSize                = 0x14;
        boneScalingPadding              = 0x38;
        boneScalingOffset               = boneOffset + boneScalingPadding;
        boneScalingSize                 = 0x14;
        bonePivotPadding                = 0x4C;
        // Vertice
        verticeCount                    = ReadUInt(startOffset + 0x3C);
        verticeOffset                   = ReadUInt(startOffset + 0x40);
        verticeSize                     = 0x30;
        verticePositionPadding          = 0x00;
        // Color
        colorCount                      = ReadUInt(startOffset + 0x48);
        colorOffset                     = ReadUInt(startOffset + 0x4C);
        colorSize                       = 0x28;
        colorColorOffset                = colorOffset + 0x00;
        colorColorSize                  = 0x14;
        colorColorPadding               = 0x00;
        colorAlphaOffset                = colorOffset + 0x14;
        colorAlphaSize                  = 0x14;
        colorAlphaPadding               = 0x14;
        // Weight
        weightCount                     = ReadUInt(startOffset + 0x58);
        weightOffset                    = ReadUInt(startOffset + 0x5C);
        weightSize                      = 0x14;
        // Transform
        transformCount                  = ReadUInt(startOffset + 0x60);
        transformOffset                 = ReadUInt(startOffset + 0x64);
        transformSize                   = 0x3C;
        transformTranslationPadding     = 0x00;
        transformTranslationOffset      = transformOffset + transformTranslationPadding;
        transformTranslationSize        = 0x14;
        transformRotationPadding        = 0x14;
        transformRotationOffset         = transformOffset + transformRotationPadding;
        transformRotationSize           = 0x14;
        transformScalingPadding         = 0x28;
        transformScalingOffset          = transformOffset + transformScalingPadding;
        transformScalingSize            = 0x14;
        // Bounding
        boundingOffset                  = 0xA0;
        boundingSize                    = 0x38;
        boundingRadius                  = 0x18;
        // Collision
        collisionBoxPadding             = 0x1C;
        collisionRadius                 = 0x34;
        collisionCount                  = ReadUInt(startOffset + 0xE0);
        collisionOffset                 = ReadUInt(startOffset + 0xE4);
        collisionSize                   = 0x0C;
        // Normal
        normalCount                     = ReadUInt(startOffset + 0xE8);
        normalOffset                    = ReadUInt(startOffset + 0xEC);
        normalSize                      = 0x0C;
        // Attachment
        attachmentCount                 = ReadUInt(startOffset + 0xF0);
        attachmentOffset                = ReadUInt(startOffset + 0xF4);
        attachmentSize                  = 0x28;
        attachmentPositionPadding       = 0x08;
        // Event
        eventCount                      = ReadUInt(startOffset + 0x100);
        eventOffset                     = ReadUInt(startOffset + 0x104);
        eventSize                       = 0x24;
        eventPositionPadding            = 0x0C;
        // Light
        lightCount                      = ReadUInt(startOffset + 0x108);
        lightOffset                     = ReadUInt(startOffset + 0x10C);
        lightSize                       = 0x9C;
        lightPositionPadding            = 0x04;
        lightAmbientColorPadding        = 0x10;
        lightAmbientColorOffset         = lightOffset + lightAmbientColorPadding;
        lightAmbientColorSize           = 0x14;
        lightAmbientIntensityPadding    = 0x24;
        lightAmbientIntensityOffset     = lightOffset + lightAmbientIntensityPadding;
        lightAmbientIntensitySize       = 0x14;
        lightDiffuseColorPadding        = 0x38;
        lightDiffuseColorOffset         = lightOffset + LightDiffuseColorPadding;
        lightDiffuseColorSize           = 0x14;
        lightDiffuseIntensityPadding    = 0x4C;
        lightDiffuseIntensityOffset     = lightOffset + lightDiffuseIntensityPadding;
        lightDiffuseIntensitySize       = 0x14;
        lightAttenuationStartPadding    = 0x60;
        lightAttenuationStartOffset     = lightOffset + lightAttenuationStartPadding;
        lightAttenuationStartSize       = 0x14;
        lightAttenuationEndPadding      = 0x74;
        lightAttenuationEndOffset       = lightOffset + lightAttenuationEndPadding;
        lightAttenuationEndSize         = 0x14;
        lightVisibilityPadding          = 0x88;
        lightVisibilityOffset           = lightOffset + lightVisibilityPadding;
        lightVisibilitySize             = 0x14;
        // Camera
        cameraCount                     = ReadUInt(startOffset + 0x110);
        cameraOffset                    = ReadUInt(startOffset + 0x114);
        cameraSize                      = 0x64;
        cameraFovPadding                = 0x04;
        cameraFarclipPadding            = 0x08;
        cameraNearclipPadding           = 0x0C;
        cameraTranslationPosPadding     = 0x10;
        cameraTranslationPosOffset      = cameraOffset + cameraTranslationPosPadding;
        cameraTranslationPosSize        = 0x14;
        cameraPositionPadding           = 0x24;
        cameraTranslationTarPadding     = 0x30;
        cameraTranslationTarOffset      = cameraOffset + cameraTranslationTarPadding;
        cameraTranslationTarSize        = 0x14;
        cameraTargetPadding             = 0x44;
        cameraRollPadding               = 0x50;
        cameraRollOffset                = cameraOffset + cameraRollPadding;
        cameraRollSize                  = 0x14;
        // Ribbon
        ribbonCount                     = ReadUInt(startOffset + 0x120);
        ribbonOffset                    = ReadUInt(startOffset + 0x124);
        ribbonSize                      = 0xB0;
        ribbonPositionPadding           = 0x08;
        ribbonColorPadding              = 0x24;
        ribbonColorOffset               = ribbonOffset + ribbonColorPadding;
        ribbonColorSize                 = 0x14;
        ribbonAlphaPadding              = 0x38;
        ribbonAlphaOffset               = ribbonOffset + ribbonAlphaPadding;
        ribbonAlphaSize                 = 0x14;
        ribbonHeightAbovePadding        = 0x4C;
        ribbonHeightAboveOffset         = ribbonOffset + ribbonHeightAbovePadding;
        ribbonHeightAboveSize           = 0x14;
        ribbonHeightBelowPadding        = 0x60;
        ribbonHeightBelowOffset         = ribbonOffset + ribbonHeightBelowPadding;
        ribbonHeightBelowSize           = 0x14;
        ribbonEdgeRatePadding           = 0x74;
        ribbonEdgeLifespanPadding       = 0x78;
        ribbonGravityPadding            = 0x7C;
        ribbonVisibilityPadding         = 0x98;
        ribbonVisibilityOffset          = ribbonOffset + ribbonVisibilityPadding;
        ribbonVisibilitySize            = 0x14;
        // Particle
        particleCount                   = ReadUInt(startOffset + 0x128);
        particleOffset                  = ReadUInt(startOffset + 0x12C);
        particleSize                    = 0x1DC;
        particlePositionPadding         = 0x08;
        particleEmissionSpeedPadding    = 0x34;
        particleEmissionSpeedOffset     = particleOffset + particleEmissionSpeedPadding;
        particleEmissionSpeedSize       = 0x14;
        particleSpeedPadding            = 0x48;
        particleSpeedOffset             = particleOffset + particleSpeedPadding;
        particleSpeedSize               = 0x14;
        particleVerticalPadding         = 0x5C;
        particleVerticalOffset          = particleOffset + particleVerticalPadding;
        particleVerticalSize            = 0x14;
        particleHorizontalPadding       = 0x70;
        particleHorizontalOffset        = particleOffset + particleHorizontalPadding;
        particleHorizontalSize          = 0x14;
        particleGravityPadding          = 0x84;
        particleGravityOffset           = particleOffset + particleGravityPadding;
        particleGravitySize             = 0x14;
        particleLifespanPadding         = 0x98;
        particleLifespanOffset          = particleOffset + particleLifespanPadding;
        particleLifespanSize            = 0x14;
        particleLifespanVaryPadding     = 0xAC;
        particleEmissionRatePadding     = 0xB0;
        particleEmissionRateOffset      = particleOffset + particleEmissionRatePadding;
        particleEmissionRateSize        = 0x14;
        particleEmissionRateVaryPadding = 0xC4;
        particleEmissionLengthPadding   = 0xC8;
        particleEmissionLengthOffset    = particleOffset + particleEmissionLengthPadding;
        particleEmissionLengthSize      = 0x14;
        particleEmissionWidthPadding    = 0xDC;
        particleEmissionWidthOffset     = particleOffset + particleEmissionWidthPadding;
        particleEmissionWidthSize       = 0x14;
        particleSourcePadding           = 0xF0;
        particleSourceOffset            = particleOffset + particleSourcePadding;
        particleSourceSize              = 0x14;
        particleColorPadding            = 0x104;
        particleColorOffset             = particleOffset + particleColorPadding;
        particleColorSize               = 0x10;
        particleAlphaPadding            = 0x114;
        particleAlphaOffset             = particleOffset + particleAlphaPadding;
        particleAlphaSize               = 0x10;
        particleScalePadding            = 0x124;
        particleScaleOffset             = particleOffset + particleScalePadding;
        particleScaleSize               = 0x10;
        particleScaleVaryPadding        = 0x134;
        particleTailLengthPadding       = 0x15C;
        particleTwinkleSpeedPadding     = 0x160;
        particleTwinklePercentPadding   = 0x164;
        particleTwinkleScalePadding     = 0x168;
        particleBurstPadding            = 0x170;
        particleDragPadding             = 0x174;
        particleBaseSpinPadding         = 0x178;
        particleBaseSpinVaryPadding     = 0x17C;
        particleSpinPadding             = 0x180;
        particleSpinVaryPadding         = 0x184;
        particleTumbleMinPadding        = 0x188;
        particleTumbleMaxPadding        = 0x194;
        particleWindVectorPadding       = 0x1A0;
        particleWindTimePadding         = 0x1AC;
        particleFollowSpeed1Padding     = 0x1B0;
        particleFollowScale1Padding     = 0x1B4;
        particleFollowSpeed2Padding     = 0x1B8;
        particleFollowScale2Padding     = 0x1Bc;
        particleEnabledPadding          = 0x1C8;
        particleEnabledOffset           = particleOffset + particleEnabledPadding;
        particleEnabledSize             = 0x14;
    }
    if (version <= 255)
    {
        Printf("INVALID File Version [%u] - Set to Alpha mode\n", version);
        // Expansion
        expansion                       = 0; // Invalid - set to Alpha
        // Sequence
        sequenceCount                   = ReadUInt(startOffset + 0x1C);
        sequenceOffset                  = ReadUInt(startOffset + 0x20);
        sequenceSize                    = 0x44;
        sequenceIdPadding               = 0x00;
        sequenceSubPadding              = 0x02;
        sequenceFlagPadding             = 0x10;
        sequencePositionPadding         = 0x24;
        // Bone
        boneCount                       = ReadUInt(startOffset + 0x34);
        boneOffset                      = ReadUInt(startOffset + 0x38);
        boneSize                        = 0x6C;
        boneTranslationPadding          = 0x0C;
        boneTranslationOffset           = boneOffset + boneTranslationPadding;
        boneTranslationSize             = 0x1C;
        boneRotationPadding             = 0x28;
        boneRotationOffset              = boneOffset + boneRotationPadding;
        boneRotationSize                = 0x1C;
        boneScalingPadding              = 0x44;
        boneScalingOffset               = boneOffset + boneScalingPadding;
        boneScalingSize                 = 0x1C;
        bonePivotPadding                = 0x60;
        // Vertice
        verticeCount                    = ReadUInt(startOffset + 0x44);
        verticeOffset                   = ReadUInt(startOffset + 0x48);
        verticeSize                     = 0x30;
        verticePositionPadding          = 0x00;
        // Color
        colorCount                      = ReadUInt(startOffset + 0x54);
        colorOffset                     = ReadUInt(startOffset + 0x58);
        colorSize                       = 0x38;
        colorColorPadding               = 0x00;
        colorColorOffset                = colorOffset + 0x00;
        colorColorSize                  = 0x1C;
        colorAlphaPadding               = 0x1C;
        colorAlphaOffset                = colorOffset + 0x1C;
        colorAlphaSize                  = 0x1C;
        // Weight
        weightCount                     = ReadUInt(startOffset + 0x64);
        weightOffset                    = ReadUInt(startOffset + 0x68);
        weightSize                      = 0x1C;
        // Transform
        transformCount                  = ReadUInt(startOffset + 0x74);
        transformOffset                 = ReadUInt(startOffset + 0x78);
        transformSize                   = 0x54;
        transformTranslationPadding     = 0x00;
        transformTranslationOffset      = transformOffset + transformTranslationPadding;
        transformTranslationSize        = 0x1C;
        transformRotationPadding        = 0x1C;
        transformRotationOffset         = transformOffset + transformRotationPadding;
        transformRotationSize           = 0x1C;
        transformScalingPadding         = 0x38;
        transformScalingOffset          = transformOffset + transformScalingPadding;
        transformScalingSize            = 0x1C;
        // Bounding
        boundingOffset                  = 0xB4;
        boundingSize                    = 0x38;
        boundingRadius                  = 0x18;
        // Collision
        collisionBoxPadding             = 0x1C;
        collisionRadius                 = 0x34;
        collisionCount                  = ReadUInt(startOffset + 0xF4);
        collisionOffset                 = ReadUInt(startOffset + 0xF8);
        collisionSize                   = 0x0C;
        // Normal
        normalCount                     = ReadUInt(startOffset + 0xFC);
        normalOffset                    = ReadUInt(startOffset + 0x100);
        normalSize                      = 0x0C;
        // Attachment
        attachmentCount                 = ReadUInt(startOffset + 0x104);
        attachmentOffset                = ReadUInt(startOffset + 0x108);
        attachmentSize                  = 0x30;
        attachmentPositionPadding       = 0x08;
        // Event
        eventCount                      = ReadUInt(startOffset + 0x114);
        eventOffset                     = ReadUInt(startOffset + 0x118);
        eventSize                       = 0x2C;
        eventPositionPadding            = 0x0C;
        // Light
        lightCount                      = ReadUInt(startOffset + 0x11C);
        lightOffset                     = ReadUInt(startOffset + 0x120);
        lightSize                       = 0xD4;
        lightPositionPadding            = 0x04;
        lightAmbientColorPadding        = 0x10;
        lightAmbientColorOffset         = lightOffset + lightAmbientColorPadding;
        lightAmbientColorSize           = 0x1C;
        lightAmbientIntensityPadding    = 0x2C;
        lightAmbientIntensityOffset     = lightOffset + lightIntensityPadding;
        lightAmbientIntensitySize       = 0x1C;
        lightDiffuseColorPadding        = 0x48;
        lightDiffuseColorOffset         = lightOffset + lightDiffuseColorPadding;
        lightDiffuseColorSize           = 0x1C;
        lightDiffuseIntensityPadding    = 0x64;
        lightDiffuseIntensityOffset     = lightOffset + lightDiffuseIntensityPadding;
        lightDiffuseIntensitySize       = 0x1C;
        lightAttenuationStartPadding    = 0x80;
        lightAttenuationStartOffset     = lightOffset + lightAttenuationStartPadding;
        lightAttenuationStartSize       = 0x1C;
        lightAttenuationEndPadding      = 0x9C;
        lightAttenuationEndOffset       = lightOffset + lightAttenuationEndPadding;
        lightAttenuationEndSize         = 0x1C;
        lightVisibilityPadding          = 0xB8;
        lightVisibilityOffset           = lightOffset + lightVisibilityPadding;
        lightVisibilitySize             = 0x1C;
        // Camera
        cameraCount                     = ReadUInt(startOffset + 0x124);
        cameraOffset                    = ReadUInt(startOffset + 0x128);
        cameraSize                      = 0x7C;
        cameraFovPadding                = 0x04;
        cameraFarclipPadding            = 0x08;
        cameraNearclipPadding           = 0x0C;
        cameraTranslationPosPadding     = 0x10;
        cameraTranslationPosOffset      = cameraOffset + cameraTranslationPosPadding;
        cameraTranslationPosSize        = 0x1C;
        cameraPositionPadding           = 0x2C;
        cameraTranslationTarPadding     = 0x38;
        cameraTranslationTarOffset      = cameraOffset + cameraTranslationTarPadding;
        cameraTranslationTarSize        = 0x1C;
        cameraTargetPadding             = 0x54;
        cameraRollPadding               = 0x60;
        cameraRollOffset                = cameraOffset + cameraRollPadding;
        cameraRollSize                  = 0x1C;
        // Ribbon
        ribbonCount                     = ReadUInt(startOffset + 0x134);
        ribbonOffset                    = ReadUInt(startOffset + 0x138);
        ribbonSize                      = 0xDC;
        ribbonPositionPadding           = 0x08;
        ribbonColorPadding              = 0x24;
        ribbonColorOffset               = ribbonOffset + ribbonColorPadding;
        ribbonColorSize                 = 0x1C;
        ribbonAlphaPadding              = 0x40;
        ribbonAlphaOffset               = ribbonOffset + ribbonAlphaPadding;
        ribbonAlphaSize                 = 0x1C;
        ribbonHeightAbovePadding        = 0x5C;
        ribbonHeightAboveOffset         = ribbonOffset + ribbonHeightAbovePadding;
        ribbonHeightAboveSize           = 0x1C;
        ribbonHeightBelowPadding        = 0x78;
        ribbonHeightBelowOffset         = ribbonOffset + ribbonHeightBelowPadding;
        ribbonHeightBelowSize           = 0x1C;
        ribbonEdgeRatePadding           = 0x94;
        ribbonEdgeLifespanPadding       = 0x98;
        ribbonGravityPadding            = 0x9C;
        ribbonVisibilityPadding         = 0xC0;
        ribbonVisibilityOffset          = ribbonOffset + ribbonVisibilityPadding;
        ribbonVisibilitySize            = 0x1C;
        // Particle
        particleCount                   = ReadUInt(startOffset + 0x13C);
        particleOffset                  = ReadUInt(startOffset + 0x140);
        particleSize                    = 0x1F8;
        particlePositionPadding         = 0x08;
        particleEmissionSpeedPadding    = 0x2A;
        particleEmissionSpeedOffset     = particleOffset + particleEmissionSpeedPadding;
        particleEmissionSpeedSize       = 0x1C;
        particleSpeedPadding            = 0x50;
        particleSpeedOffset             = particleOffset + particleSpeedPadding;
        particleSpeedSize               = 0x1C;
        particleVerticalPadding         = 0x6C;
        particleVerticalOffset          = particleOffset + particleVerticalPadding;
        particleVerticalSize            = 0x1C;
        particleHorizontalPadding       = 0x88;
        particleHorizontalOffset        = particleOffset + particleHorizontalPadding;
        particleHorizontalSize          = 0x1C;
        particleGravityPadding          = 0xA4;
        particleGravityOffset           = particleOffset + particleGravityPadding;
        particleGravitySize             = 0x1C;
        particleLifespanPadding         = 0xC0;
        particleLifespanOffset          = particleOffset + particleLifespanPadding;
        particleLifespanSize            = 0x1C;
        particleEmissionRatePadding     = 0xDC;
        particleEmissionRateOffset      = particleOffset + particleEmissionRateOffset;
        particleEmissionRateSize        = 0x1C;
        particleEmissionLengthPadding   = 0xF8;
        particleEmissionLengthOffset    = particleOffset + particleEmissionLengthPadding;
        particleEmissionLengthSize      = 0x1C;
        particleEmissionWidthPadding    = 0x114;
        particleEmissionWidthOffset     = particleOffset + particleEmissionWidthPadding;
        particleEmissionWidthSize       = 0x1C;
        particleSourcePadding           = 0x130;
        particleSourceOffset            = particleOffset + particleSourcePadding;
        particleSourceSize              = 0x1C;
        particleMidpointPadding         = 0x14C;
        particleColorPadding            = 0x150;
        particleScalePadding            = 0x15C;
        particleTailLengthPadding       = 0x17C;
        particleTwinkleSpeedPadding     = 0x180;
        particleTwinklePercentPadding   = 0x184;
        particleTwinkleScalePadding     = 0x188;
        particleBurstPadding            = 0x190;
        particleDragPadding             = 0x194;
        particleSpinPadding             = 0x198;
        particleTumbleMinPadding        = 0x19C;
        particleTumbleMaxPadding        = 0x1A8;
        particleWindVectorPadding       = 0x1B4;
        particleWindTimePadding         = 0x1C0;
        particleFollowSpeed1Padding     = 0x1C4;
        particleFollowScale1Padding     = 0x1C8;
        particleFollowSpeed2Padding     = 0x1CC;
        particleFollowScale2Padding     = 0x1D0;
        particleEnabledPadding          = 0x1DC;
        particleEnabledOffset           = particleOffset + particleEnabledPadding;
        particleEnabledSize             = 0x1C;
    }
}
// ================================================================================================
///////////////////////////////////////////////////////////////////////////////////////////////////
//// START ////////////////////////////////////////////////////////////////////////////////////////
// ==== EXECUTION OUTPUT ==========================================================================
Printf("Executing Wallcraft M2 Modifier...\n");

if (sequenceEnabled || basicScaling)
{
    Printf("==== SEQUENCE ====\n Sequence Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", sequenceCount, sequenceOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(sequenceOffset + outputIter));
    }
    Printf("\n"); 
}
if (boneEnabled || basicScaling)
{
    Printf("==== BONE ====\n Bone Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", boneCount, boneOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(boneOffset + outputIter));
    }
    Printf("\n");
}
if (verticeEnabled || basicScaling)
{
    Printf("==== VERTICE ====\n Vertice Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", verticeCount, verticeOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(verticeOffset + outputIter));
    }
    Printf("\n");    
}
if (colorEnabled && !basicScaling)
{
    Printf("==== COLOR ====\n Color Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", colorCount, colorOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(colorOffset + outputIter));
    }
    Printf("\n");    
}
if (weightEnabled && !basicScaling)
{
    Printf("==== WEIGHT ====\n Weight Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", weightCount, weightOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(weightOffset + outputIter));
    }
    Printf("\n");    
}
if (transformEnabled && !basicScaling)
{
    Printf("==== TRANSFORM ====\n Transform Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", transformCount, transformOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(transformOffset + outputIter));
    }
    Printf("\n");    
}
if (boundingEnabled || basicScaling)
{
    Printf("==== BOUNDING ====\n Bounding Box\nStart: 0x%X\nFirst 12 bytes: ", boundingOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(boundingOffset + outputIter));
    }
    Printf("\n");   
}
if (collisionEnabled || basicScaling)
{
    Printf("==== COLLISION ====\n Collision Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", collisionCount, collisionOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(collisionOffset + outputIter));
    }
    Printf("\n");   
}
if (normalEnabled || basicScaling)
{
    Printf("==== NORMAL ====\n Normal Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", normalCount, normalOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(normalOffset + outputIter));
    }
    Printf("\n");   
}
if (attachmentEnabled || basicScaling)
{
    Printf("==== ATTACHMENT ====\n Attachment Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", attachmentCount, attachmentOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(attachmentOffset + outputIter));
    }
    Printf("\n");   
}
if (eventEnabled || basicScaling)
{
    Printf("==== EVENT ====\n Event Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", eventCount, eventOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(eventOffset + outputIter));
    }
    Printf("\n");   
}
if (lightEnabled || basicScaling)
{
    Printf("==== LIGHT ====\n Light Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", lightCount, lightOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(lightOffset + outputIter));
    }
    Printf("\n");   
}
if (cameraEnabled || basicScaling)
{
    Printf("==== CAMERA ====\n Camera Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", cameraCount, cameraOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(cameraOffset + outputIter));
    }
    Printf("\n");  
}
if (ribbonEnabled || basicScaling)
{
    Printf("==== RIBBON ====\n Ribbon Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", ribbonCount, ribbonOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(ribbonOffset + outputIter));
    }
    Printf("\n");   
}
if (particleEnabled || basicScaling)
{
    Printf("==== PARTICLE ====\n Particle Count: [%u]\nStart: 0x%X\nFirst 12 bytes: ", particleCount, particleOffset);
    for (outputIter = 0; outputIter < 12; outputIter++)
    {
        Printf("%02X ", ReadUByte(particleOffset + outputIter));
    }
    Printf("\n");    
}
// ==== SEQUENCE ==================================================================================
if (sequenceEnabled || basicScaling) 
{
    // Catch
    if (sequenceCount > 0 && sequenceOffset > 0)
    {
        // Iterate
        for (trackIter = 0; trackIter < sequenceCount; trackIter++)
        {
            // Move
            pos = sequenceOffset + (trackIter * sequenceSize) + sequencePositionPadding;
            // Read
            x  = ReadFloat(pos + (floatSize * 0)); // BoxMinX
            y  = ReadFloat(pos + (floatSize * 1)); // BoxMinY
            z  = ReadFloat(pos + (floatSize * 2)); // BoxMinZ
            x2 = ReadFloat(pos + (floatSize * 3)); // BoxMaxX
            y2 = ReadFloat(pos + (floatSize * 4)); // BoxMaxY
            z2 = ReadFloat(pos + (floatSize * 5)); // BoxMaxZ
            r  = ReadFloat(pos + (floatSize * 6)); // Bounding Radius
            // Output
            if (debug)
            {
                Printf("    Sequence[%d] Offset[0x%X] CURRENT MIN VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                Printf("    Sequence[%d] Offset[0x%X] CURRENT MAX VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x2, y2, z2);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0), x  * sequencePositionX);
                WriteFloat(pos + (floatSize * 1), y  * sequencePositionY);
                WriteFloat(pos + (floatSize * 2), z  * sequencePositionZ);
                WriteFloat(pos + (floatSize * 3), x2 * sequencePositionX);
                WriteFloat(pos + (floatSize * 4), y2 * sequencePositionY);
                WriteFloat(pos + (floatSize * 5), z2 * sequencePositionZ);
                WriteFloat(pos + (floatSize * 6), r  * sequencePositionR);
                // Output
                if (debug)
                {
                    Printf("    Sequence[%d] Offset[0x%X] NEW MIN VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                    Printf("    Sequence[%d] Offset[0x%X] NEW MAX VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x2, y2, z2);
                }
            }
            // Test
            if (testRun)
            {
                Printf("TEST: Sequences complete.\n");
                break;
            }
        }
    }
    // Error
    else
    {
        Printf("  No Sequence Count(%d) or Sequence Offset(%d).\n", sequenceCount, sequenceOffset);
    }
}
// ==== BONE ======================================================================================
if (boneEnabled || basicScaling)
{
    // Catch
    if (boneCount > 0 && boneOffset > 0)
    {
        // Iterate
        for (blockIter = 0; blockIter < boneCount; blockIter++)
        {
            // Declare
            currentTrack            = boneOffset   + (blockIter * boneSize);
            boneTranslationOffset   = currentTrack + boneTranslationPadding;
            boneRotationOffset      = currentTrack + boneRotationPadding;
            boneScalingOffset       = currentTrack + boneScalingPadding;
            // Output
            if (!silent)
            {
                Printf("\nProcessing Bone: %u at 0x%X\n", blockIter, currentTrack);
            }
            // ---- TRANSLATION TRACK ----             
            trackInterpolation          =  ReadUShort(boneTranslationOffset + 0x00);
            trackGlobalSeq              =   ReadShort(boneTranslationOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(boneTranslationOffset + 0x04);
                trackRangesOffset       =    ReadUInt(boneTranslationOffset + 0x08);
                trackTimestamps         =    ReadUInt(boneTranslationOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(boneTranslationOffset + 0x10);
                trackKeyPairs           =    ReadUInt(boneTranslationOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(boneTranslationOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(boneTranslationOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(boneTranslationOffset + 0x08);
                trackKeyPairs           =    ReadUInt(boneTranslationOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(boneTranslationOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Translation] Bone[%u] @ 0x%X\n",   blockIter, boneTranslationOffset);
                Printf("  Interpolation: %u\n",             trackInterpolation);
                Printf("  Global Seq   : %d\n",             trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",      trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * vectorSize);
                        // Read
                        x = ReadFloat(pos + (floatSize * 0));
                        y = ReadFloat(pos + (floatSize * 1));
                        z = ReadFloat(pos + (floatSize * 2));
                        // Output
                        if (debug) 
                        {
                            Printf("    Bone[%u] Current Translation Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                        }
                        // Write
                        if (!readOnly)
                        {
                            WriteFloat(pos + (floatSize * 0), x * boneTranslationPositionX);
                            WriteFloat(pos + (floatSize * 1), y * boneTranslationPositionY);
                            WriteFloat(pos + (floatSize * 2), z * boneTranslationPositionZ);
                            // Output
                            if (debug)
                            {
                                Printf("    Bone[%u] New Translation Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Translation complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Find .anim files
                        pos = sequenceOffset + (trackIter * sequenceSize);
                        sequenceId      = ReadUShort(pos + sequenceIdPadding);
                        sequenceSub     = ReadUShort(pos + sequenceSubPadding);
                        sequenceFlags   = ReadUInt(pos + sequenceFlagPadding);
                        // Output
                        if (debug)
                        {
                            Printf("Debug: sequenceId[%04d] sequenceSub[%02d] sequenceFlags[%u]\n", sequenceId, sequenceSub, sequenceFlags);
                        }
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Open .anim files
                        if (!(sequenceFlags & 0x20) && subtrackCount > 0)
                        {
                            animFile = Str("%s%s%04d-%02d.anim", filePath, fileName, sequenceId, sequenceSub);
                            FileOpen( animFile );
                            if (debug)
                            {
                                Printf( "Processing %s \n", animFile );
                            }
                            // If no charMagic then we are parsing .anim file
                            pos = ReadUInt(startOffset);
                            if (pos)
                            {
                                Printf( "Failed to open %s \n", animFile );
                            }
                        }
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * vectorSize);
                                // Read
                                x = ReadFloat(pos + (floatSize * 0));
                                y = ReadFloat(pos + (floatSize * 1));
                                z = ReadFloat(pos + (floatSize * 2));
                                // Output
                                if (debug) 
                                {
                                    Printf("    Bone[%u] Current Translation Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    WriteFloat(pos + (floatSize * 0), x * boneTranslationPositionX);
                                    WriteFloat(pos + (floatSize * 1), y * boneTranslationPositionY);
                                    WriteFloat(pos + (floatSize * 2), z * boneTranslationPositionZ);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Bone[%u] New Translation Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Translation complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                        // Close .anim files
                        if (!(sequenceFlags & 0x20) && subtrackCount > 0)
                        {
                            // If no charMagic then we are parsing .anim file
                            pos = ReadUInt(startOffset);
                            if (!pos)
                            {
                                // Save
                                if (autoSave)
                                {
                                    if (debug)
                                    {
                                        PrintF( "Saving %s \n", animFile );
                                    }
                                    FileSave( animFile );
                                }
                                // Close if autoSave enabled or readOnly enabled
                                if ((autoClose && autoSave) || (autoClose && readOnly))
                                {
                                    if (debug)
                                    {
                                        Printf( "Closing %s \n", animFile );
                                    }
                                    FileClose();
                                }
                                // Reopen
                                if (debug)
                                {
                                    Printf( "Opening %s \n", rootFile );
                                }
                                FileOpen( rootFile );
                            }
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- ROTATION TRACK ----
            trackInterpolation      =  ReadUShort(boneRotationOffset + 0x00);
            trackGlobalSeq          =   ReadShort(boneRotationOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(boneRotationOffset + 0x04);
                trackRangesOffset       =    ReadUInt(boneRotationOffset + 0x08);
                trackTimestamps         =    ReadUInt(boneRotationOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(boneRotationOffset + 0x10);
                trackKeyPairs           =    ReadUInt(boneRotationOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(boneRotationOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(boneRotationOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(boneRotationOffset + 0x08);
                trackKeyPairs           =    ReadUInt(boneRotationOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(boneRotationOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("\n[Rotation] Bone[%u] @ 0x%X\n",    blockIter, boneRotationOffset);
                Printf("  Interpolation: %u\n",             trackInterpolation);
                Printf("  Global Seq   : %d\n",             trackGlobalSeq);
                if (expansion <= 2)
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",      trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Animation Count (%u) does not match Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * quaternionSize;                        
                        // Read
                        sx = ReadUShort(pos + (shortSize * 0));
                        sy = ReadUShort(pos + (shortSize * 1));
                        sz = ReadUShort(pos + (shortSize * 2));
                        sw = ReadUShort(pos + (shortSize * 3));
                        // Short to float
                        x = stf(sx);
                        y = stf(sy);
                        z = stf(sz);
                        w = stf(sw);
                        // Output
                        if (debug) 
                        {
                            Printf("    Bone[%u] Current Rotation Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Float to short
                            sx = fts(x * boneRotationPositionX);
                            sy = fts(y * boneRotationPositionY);
                            sz = fts(z * boneRotationPositionZ);
                            sw = fts(w * boneRotationPositionW);
                            // Write
                            WriteShort(pos + (shortSize * 0), sx);
                            WriteShort(pos + (shortSize * 1), sy);
                            WriteShort(pos + (shortSize * 2), sz);
                            WriteShort(pos + (shortSize * 3), sw);
                            // Output
                            if (debug) 
                            {
                                Printf("    Bone[%u] New Rotation Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Rotation complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Find .anim files
                        pos = sequenceOffset + (trackIter * sequenceSize);
                        sequenceId      = ReadUShort(pos + sequenceIdPadding);
                        sequenceSub     = ReadUShort(pos + sequenceSubPadding);
                        sequenceFlags   = ReadUInt(pos + sequenceFlagPadding);
                        // Output
                        if (debug)
                        {
                            Printf("Debug: sequenceId[%04d] sequenceSub[%02d] sequenceFlags[%u]\n", sequenceId, sequenceSub, sequenceFlags);
                        }
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Open .anim files
                        if (!(sequenceFlags & 0x20) && subtrackCount > 0)
                        {
                            animFile = Str("%s%s%04d-%02d.anim", filePath, fileName, sequenceId, sequenceSub);
                            FileOpen( animFile );
                            if (debug)
                            {
                                Printf( "Processing %s \n", animFile );
                            }
                            // If no charMagic then we are parsing .anim file
                            pos = ReadUInt(startOffset);
                            if (pos)
                            {
                                Printf( "Failed to open %s \n", animFile );
                            }
                        }
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * quaternionSize);
                                // Read
                                sx = ReadUShort(pos + (shortSize * 0));
                                sy = ReadUShort(pos + (shortSize * 1));
                                sz = ReadUShort(pos + (shortSize * 2));
                                sw = ReadUShort(pos + (shortSize * 3));
                                // Short to float
                                x = stf(sx);
                                y = stf(sy);
                                z = stf(sz);
                                w = stf(sw);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Bone[%u] Current Rotation Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f, %.6f, %.6f, %.6f)\n", x, y, z, w);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Float to short
                                    sx = fts(x * boneRotationPositionX);
                                    sy = fts(y * boneRotationPositionY);
                                    sz = fts(z * boneRotationPositionZ);
                                    sw = fts(w * boneRotationPositionW);
                                    // Write
                                    WriteShort(pos + (shortSize * 0), sx);
                                    WriteShort(pos + (shortSize * 1), sy);
                                    WriteShort(pos + (shortSize * 2), sz);
                                    WriteShort(pos + (shortSize * 3), sw);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Bone[%u] New Rotation Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f, %.6f, %.6f, %.6f)\n", x, y, z, w);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Rotation complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                        // Close .anim files
                        if (!(sequenceFlags & 0x20) && subtrackCount > 0)
                        {
                            // If no charMagic then we are parsing .anim file
                            pos = ReadUInt(startOffset);
                            if (!pos)
                            {
                                // Save
                                if (autoSave)
                                {
                                    if (debug)
                                    {
                                        PrintF( "Saving %s \n", animFile );
                                    }
                                    FileSave( animFile );
                                }
                                // Close if autoSave enabled or readOnly enabled
                                if ((autoClose && autoSave) || (autoClose && readOnly))
                                {
                                    if (debug)
                                    {
                                        Printf( "Closing %s \n", animFile );
                                    }
                                    FileClose();
                                }
                                // Reopen
                                if (debug)
                                {
                                    Printf( "Opening %s \n", rootFile );
                                }
                                FileOpen( rootFile );
                            }
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- SCALING TRACK ----
            trackInterpolation      =  ReadUShort(boneScalingOffset + 0x00);
            trackGlobalSeq          =   ReadShort(boneScalingOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(boneScalingOffset + 0x04);
                trackRangesOffset       =    ReadUInt(boneScalingOffset + 0x08);
                trackTimestamps         =    ReadUInt(boneScalingOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(boneScalingOffset + 0x10);
                trackKeyPairs           =    ReadUInt(boneScalingOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(boneScalingOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(boneScalingOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(boneScalingOffset + 0x08);
                trackKeyPairs           =    ReadUInt(boneScalingOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(boneScalingOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("\n[Scaling] Bone[%u] @ 0x%X\n",     blockIter, boneScalingOffset);
                Printf("  Interpolation: %u\n",             trackInterpolation);
                Printf("  Global Seq   : %d\n",             trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",      trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Animation Count (%u) does not match Pairs (%u)!\n", boneTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * vectorSize);
                        // Read
                        x = ReadFloat(pos + (floatSize * 0));
                        y = ReadFloat(pos + (floatSize * 1));
                        z = ReadFloat(pos + (floatSize * 2));
                        // Output
                        if (debug) 
                        {
                            Printf("    Bone[%u] Current Scaling Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                        }
                        // Write
                        if (!readOnly)
                        {
                            WriteFloat(pos + (floatSize * 0), x * boneScalePositionX);
                            WriteFloat(pos + (floatSize * 1), y * boneScalePositionY);
                            WriteFloat(pos + (floatSize * 2), z * boneScalePositionZ);
                            // Output
                            if (debug)
                            {
                                Printf("    Bone[%u] New Scaling Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Scaling complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Find .anim files
                        pos = sequenceOffset + (trackIter * sequenceSize);
                        sequenceId      = ReadUShort(pos + sequenceIdPadding);
                        sequenceSub     = ReadUShort(pos + sequenceSubPadding);
                        sequenceFlags   = ReadUInt(pos + sequenceFlagPadding);
                        // Output
                        if (debug)
                        {
                            Printf("Debug: sequenceId[%04d] sequenceSub[%02d] sequenceFlags[%u]\n", sequenceId, sequenceSub, sequenceFlags);
                        }
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Open .anim files
                        if (!(sequenceFlags & 0x20) && subtrackCount > 0)
                        {
                            animFile = Str("%s%s%04d-%02d.anim", filePath, fileName, sequenceId, sequenceSub);
                            FileOpen( animFile );
                            if (debug)
                            {
                                Printf( "Processing %s \n", animFile );
                            }
                            // If no charMagic then we are parsing .anim file
                            pos = ReadUInt(startOffset);
                            if (pos)
                            {
                                Printf( "Failed to open %s \n", animFile );
                            }
                        }
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * vectorSize);
                                // Read
                                x = ReadFloat(pos + (floatSize * 0));
                                y = ReadFloat(pos + (floatSize * 1));
                                z = ReadFloat(pos + (floatSize * 2));
                                // Output
                                if (debug) 
                                {
                                    Printf("    Bone[%u] Current Scaling Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    WriteFloat(pos + (floatSize * 0), x * boneScalePositionX);
                                    WriteFloat(pos + (floatSize * 1), y * boneScalePositionY);
                                    WriteFloat(pos + (floatSize * 2), z * boneScalePositionZ);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Bone[%u] New Scaling Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Scaling complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                        // Close .anim files
                        if (!(sequenceFlags & 0x20) && subtrackCount > 0)
                        {
                            // If no charMagic then we are parsing .anim file
                            pos = ReadUInt(startOffset);
                            if (!pos)
                            {
                                // Save
                                if (autoSave)
                                {
                                    if (debug)
                                    {
                                        PrintF( "Saving %s \n", animFile );
                                    }
                                    FileSave( animFile );
                                }
                                // Close if autoSave enabled or readOnly enabled
                                if ((autoClose && autoSave) || (autoClose && readOnly))
                                {
                                    if (debug)
                                    {
                                        Printf( "Closing %s \n", animFile );
                                    }
                                    FileClose();
                                }
                                // Reopen
                                if (debug)
                                {
                                    Printf( "Opening %s \n", rootFile );
                                }
                                FileOpen( rootFile );
                            }
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- BONE PIVOT ----
            pos = currentTrack + bonePivotPadding;
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            z = ReadFloat(pos + (floatSize * 2));
            if (debug)
            {
                Printf("    Pivot[%u] Offset[0x%X] CURRENT POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0), x * bonePivotPositionX);
                WriteFloat(pos + (floatSize * 1), y * bonePivotPositionY);
                WriteFloat(pos + (floatSize * 2), z * bonePivotPositionZ);
                // Output
                if (debug)
                {
                    Printf("    Pivot[%u] Offset[0x%X] NEW POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                }
            }
            // Test
            if (testRun)
            {
                Printf("TEST: Pivot complete.\n");
                break;
            }
        }
    }
    // Error
    else
    {
        Printf("  No Bone Count(%d) or Bone Offset(%d).\n", boneCount, boneOffset);
    }
}
// ==== VERTICE ===================================================================================
if (verticeEnabled || basicScaling) 
{
    // Catch
    if (verticeCount > 0 && verticeOffset > 0)
    {
        // Iterate
        for (trackIter = 0; trackIter < verticeCount; trackIter++)
        {
            // Move
            pos = verticeOffset + (trackIter * verticeSize) + verticePositionPadding;
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            z = ReadFloat(pos + (floatSize * 2));
            // Output
            if (debug)
            {
                Printf("    Vertice[%u] Offset[0x%X] CURRENT POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0), x * verticePositionX);
                WriteFloat(pos + (floatSize * 1), y * verticePositionY);
                WriteFloat(pos + (floatSize * 2), z * verticePositionZ);
                // Output
                if (debug)
                {
                    Printf("    Vertice[%u] Offset[0x%X] NEW POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                }
            }
            // Test
            if (testRun)
            {
                Printf("TEST: Vertices complete.\n");
                break;
            }
        }
    }
    // Error
    else
    {
        Printf("  No Vertice Count(%d) or Vertice Offset(%d).\n", boneCount, boneOffset);
    }
}
// ==== COLOR =====================================================================================
if (colorEnabled && !basicScaling)
{
    // Catch
    if (colorCount > 0 && colorOffset > 0)
    {
        // Iterate
        for (blockIter = 0; blockIter < colorCount; blockIter++)
        {
            // Declare
            currentTrack               = colorOffset  + (blockIter * colorSize);
            colorColorOffset           = currentTrack + colorColorPadding;
            colorAlphaOffset           = currentTrack + colorAlphaPadding;
            // Output
            if (!silent)
            {
                Printf("\nProcessing Color: %u at 0x%X\n", blockIter, currentTrack);
            }
            // ---- COLOR TRACK ----             
            trackInterpolation          =  ReadUShort(colorColorOffset + 0x00);
            trackGlobalSeq              =   ReadShort(colorColorOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(colorColorOffset + 0x04);
                trackRangesOffset       =    ReadUInt(colorColorOffset + 0x08);
                trackTimestamps         =    ReadUInt(colorColorOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(colorColorOffset + 0x10);
                trackKeyPairs           =    ReadUInt(colorColorOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(colorColorOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(colorColorOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(colorColorOffset + 0x08);
                trackKeyPairs           =    ReadUInt(colorColorOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(colorColorOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Color] Color[%u] @ 0x%X\n",        blockIter, colorColorOffset);
                Printf("  Interpolation: %u\n",             trackInterpolation);
                Printf("  Global Seq   : %d\n",             trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",  trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",  trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",      trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Move
                    pos = trackKeyPairsOffset + (trackIter * vectorSize);
                    // Read
                    r = ReadFloat(pos + (floatSize * 0));
                    g = ReadFloat(pos + (floatSize * 1));
                    b = ReadFloat(pos + (floatSize * 2));
                    // Output
                    if (debug) 
                    {
                        Printf("    Color[%u] Current Color Value[%d] @ 0x%X", blockIter, trackIter, pos);
                        Printf(" = (%.6f, %.6f, %.6f)\n", r, g, b);
                    }
                    // Write
                    if (!readOnly)
                    {
                        WriteFloat(pos + (floatSize * 0), r * colorModifierR);
                        WriteFloat(pos + (floatSize * 1), g * colorModifierG);
                        WriteFloat(pos + (floatSize * 2), b * colorModifierB);
                        // Output
                        if (debug)
                        {
                            Printf("    Color[%u] New Color Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f, %.6f, %.6f)\n", r, g, b);
                        }
                    }
                    // Test
                    if (testRun)
                    {
                        Printf("TEST: Color complete.\n");
                        break;
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- ALPHA TRACK ----             
            trackInterpolation          =  ReadUShort(colorColorOffset + 0x00);
            trackGlobalSeq              =   ReadShort(colorColorOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(colorColorOffset + 0x04);
                trackRangesOffset       =    ReadUInt(colorColorOffset + 0x08);
                trackTimestamps         =    ReadUInt(colorColorOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(colorColorOffset + 0x10);
                trackKeyPairs           =    ReadUInt(colorColorOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(colorColorOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(colorColorOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(colorColorOffset + 0x08);
                trackKeyPairs           =    ReadUInt(colorColorOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(colorColorOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Color] Alpha[%u] @ 0x%X\n",        blockIter, colorColorOffset);
                Printf("  Interpolation: %u\n",             trackInterpolation);
                Printf("  Global Seq   : %d\n",             trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",  trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",  trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",      trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Move
                    pos = trackKeyPairsOffset + (trackIter * shortSize);
                    // Read
                    a = ReadShort(pos);
                    // Output
                    if (debug) 
                    {
                        Printf("    Color[%u] Current Alpha Value[%d] @ 0x%X", blockIter, trackIter, pos);
                        Printf(" = (%u)\n", a);
                    }
                    // Write
                    if (!readOnly)
                    {
                        WriteShort(pos, a * colorModifierA);
                        // Output
                        if (debug)
                        {
                            Printf("    Color[%u] New Alpha Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%u)\n", a);
                        }
                    }
                    // Test
                    if (testRun)
                    {
                        Printf("TEST: Alpha complete.\n");
                        break;
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // Test
            if (testRun)
            {
                Printf("TEST: Color complete.\n");
                break;
            }
        }
    }
    // Error
    else
    {
        Printf("  No Color Count(%d) or Color Offset(%d).\n", colorCount, colorOffset);
    }
}
// ==== WEIGHT ====================================================================================
if (weightEnabled && !basicScaling)
{
    // Catch
    if (weightCount > 0 && weightOffset > 0)
    {
        // Iterate
        for (blockIter = 0; blockIter < weightCount; blockIter++)
        {
            // Declare
            currentTrack                = weightOffset + (blockIter * weightSize);
            // Output
            if (!silent)
            {
                Printf("\nProcessing Weight: %u at 0x%X\n", blockIter, currentTrack);
            }
            // ---- OPACITY TRACK ----             
            trackInterpolation          =  ReadUShort(currentTrack + 0x00);
            trackGlobalSeq              =   ReadShort(currentTrack + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(currentTrack + 0x04);
                trackRangesOffset       =    ReadUInt(currentTrack + 0x08);
                trackTimestamps         =    ReadUInt(currentTrack + 0x0C);
                trackTimestampsOffset   =    ReadUInt(currentTrack + 0x10);
                trackKeyPairs           =    ReadUInt(currentTrack + 0x14);
                trackKeyPairsOffset     =    ReadUInt(currentTrack + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(currentTrack + 0x04);
                trackTimestampsOffset   =    ReadUInt(currentTrack + 0x08);
                trackKeyPairs           =    ReadUInt(currentTrack + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(currentTrack + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("Weight[%u] @ 0x%X\n",   blockIter, currentTrack);
                Printf("  Interpolation: %u\n", trackInterpolation);
                Printf("  Global Seq   : %d\n", trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",      trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Move
                    pos = trackKeyPairsOffset + (trackIter * shortSize);
                    // Read
                    a = ReadShort(pos);
                    // Output
                    if (debug) 
                    {
                        Printf("    Weight[%u] Current Weight Value[%u] @ 0x%X", blockIter, trackIter, pos);
                        Printf(" = (%u)\n", a);
                    }
                    // Write
                    if (!readOnly)
                    {
                        WriteShort(pos, a * weightModifierA);
                        // Output
                        if (debug)
                        {
                            Printf("    Weight[%u] New Weight Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%u)\n", a);
                        }
                    }
                    // Test
                    if (testRun)
                    {
                        Printf("TEST: Weight complete.\n");
                        break;
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // Test
            if (testRun)
            {
                Printf("TEST: Weight complete.\n");
                break;
            }
        }
    }
    // Error
    else
    {
        Printf("  No Weight Count(%d) or Weight Offset(%d).\n", weightCount, weightOffset);
    }
}
// ==== TRANSFORM =================================================================================
if (transformEnabled && !basicScaling)
{
    // Catch
    if (transformCount > 0 && transformOffset > 0)
    {
        // Iterate
        for (blockIter = 0; blockIter < transformCount; blockIter++)
        {
            // Declare
            currentTrack                    = transformOffset   + (blockIter * transformSize);
            transformTranslationOffset      = currentTrack + transformTranslationPadding;
            transformRotationOffset         = currentTrack + transformRotationPadding;
            transformScalingOffset          = currentTrack + transformScalingPadding;
            // Output
            if (!silent)
            {
                Printf("\nProcessing Transform: %u at 0x%X\n", blockIter, currentTrack);
            }
            // ---- TRANSLATION TRACK ----              
            trackInterpolation          =  ReadUShort(transformTranslationOffset + 0x00);
            trackGlobalSeq              =   ReadShort(transformTranslationOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(transformTranslationOffset + 0x04);
                trackRangesOffset       =    ReadUInt(transformTranslationOffset + 0x08);
                trackTimestamps         =    ReadUInt(transformTranslationOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(transformTranslationOffset + 0x10);
                trackKeyPairs           =    ReadUInt(transformTranslationOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(transformTranslationOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(transformTranslationOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(transformTranslationOffset + 0x08);
                trackKeyPairs           =    ReadUInt(transformTranslationOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(transformTranslationOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Translation] Transform[%u] @ 0x%X\n",   blockIter, transformTranslationOffset);
                Printf("  Interpolation: %u\n",             trackInterpolation);
                Printf("  Global Seq   : %d\n",             trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",      trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Move
                    pos = trackKeyPairsOffset + (trackIter * vectorSize);
                    // Read
                    x = ReadFloat(pos + (floatSize * 0));
                    y = ReadFloat(pos + (floatSize * 1));
                    z = ReadFloat(pos + (floatSize * 2));
                    // Output
                    if (debug) 
                    {
                        Printf("    Transform[%u] Current Translation Value[%d] @ 0x%X", blockIter, trackIter, pos);
                        Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                    }
                    // Write
                    if (!readOnly)
                    {
                        WriteFloat(pos + (floatSize * 0), x * transformTranslationPositionX);
                        WriteFloat(pos + (floatSize * 1), y * transformTranslationPositionY);
                        WriteFloat(pos + (floatSize * 2), z * transformTranslationPositionZ);
                        // Output
                        if (debug)
                        {
                            Printf("    Transform[%u] New Translation Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                        }
                    }
                    // Test
                    if (testRun)
                    {
                        Printf("TEST: Translation complete.\n");
                        break;
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- ROTATION TRACK ----
            trackInterpolation      =  ReadUShort(transformRotationOffset + 0x00);
            trackGlobalSeq          =   ReadShort(transformRotationOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(transformRotationOffset + 0x04);
                trackRangesOffset       =    ReadUInt(transformRotationOffset + 0x08);
                trackTimestamps         =    ReadUInt(transformRotationOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(transformRotationOffset + 0x10);
                trackKeyPairs           =    ReadUInt(transformRotationOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(transformRotationOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(transformRotationOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(transformRotationOffset + 0x08);
                trackKeyPairs           =    ReadUInt(transformRotationOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(transformRotationOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("\n[Rotation] Transform[%u] @ 0x%X\n",    blockIter, transformRotationOffset);
                Printf("  Interpolation: %u\n",             trackInterpolation);
                Printf("  Global Seq   : %d\n",             trackGlobalSeq);
                if (expansion <= 2)
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",      trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Animation Count (%u) does not match Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Move
                    pos = trackKeyPairsOffset + trackIter * quaternionSize;                        
                    // Read
                    sx = ReadUShort(pos + (shortSize * 0));
                    sy = ReadUShort(pos + (shortSize * 1));
                    sz = ReadUShort(pos + (shortSize * 2));
                    sw = ReadUShort(pos + (shortSize * 3));
                    // Short to float
                    x = stf(sx);
                    y = stf(sy);
                    z = stf(sz);
                    w = stf(sw);
                    // Output
                    if (debug) 
                    {
                        Printf("    Transform[%u] Current Rotation Value[%d] @ 0x%X", blockIter, trackIter, pos);
                        Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                    }
                    // Write
                    if (!readOnly)
                    {
                        // Float to short
                        sx = fts(x * transformRotationPositionX);
                        sy = fts(y * transformRotationPositionY);
                        sz = fts(z * transformRotationPositionZ);
                        sw = fts(w * transformRotationPositionW);
                        // Write
                        WriteShort(pos + (shortSize * 0), sx);
                        WriteShort(pos + (shortSize * 1), sy);
                        WriteShort(pos + (shortSize * 2), sz);
                        WriteShort(pos + (shortSize * 3), sw);
                        // Output
                        if (debug) 
                        {
                            Printf("    Transform[%u] New Rotation Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                        }
                    }
                    // Test
                    if (testRun)
                    {
                        Printf("TEST: Rotation complete.\n");
                        break;
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- SCALING TRACK ----
            trackInterpolation      =  ReadUShort(transformScalingOffset + 0x00);
            trackGlobalSeq          =   ReadShort(transformScalingOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(transformScalingOffset + 0x04);
                trackRangesOffset       =    ReadUInt(transformScalingOffset + 0x08);
                trackTimestamps         =    ReadUInt(transformScalingOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(transformScalingOffset + 0x10);
                trackKeyPairs           =    ReadUInt(transformScalingOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(transformScalingOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(transformScalingOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(transformScalingOffset + 0x08);
                trackKeyPairs           =    ReadUInt(transformScalingOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(transformScalingOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("\n[Scaling] Transform[%u] @ 0x%X\n",     blockIter, transformScalingOffset);
                Printf("  Interpolation: %u\n",             trackInterpolation);
                Printf("  Global Seq   : %d\n",             trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",      trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Animation Count (%u) does not match Pairs (%u)!\n", transformTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Move
                    pos = trackKeyPairsOffset + (trackIter * vectorSize);
                    // Read
                    x = ReadFloat(pos + (floatSize * 0));
                    y = ReadFloat(pos + (floatSize * 1));
                    z = ReadFloat(pos + (floatSize * 2));
                    // Output
                    if (debug) 
                    {
                        Printf("    Transform[%u] Current Scaling Value[%d] @ 0x%X", blockIter, trackIter, pos);
                        Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                    }
                    // Write
                    if (!readOnly)
                    {
                        WriteFloat(pos + (floatSize * 0), x * transformScalePositionX);
                        WriteFloat(pos + (floatSize * 1), y * transformScalePositionY);
                        WriteFloat(pos + (floatSize * 2), z * transformScalePositionZ);
                        // Output
                        if (debug)
                        {
                            Printf("    Transform[%u] New Scaling Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                        }
                    }
                    // Test
                    if (testRun)
                    {
                        Printf("TEST: Scaling complete.\n");
                        break;
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // Test
            if (testRun)
            {
                Printf("TEST: Transform complete.\n");
                break;
            }
        }
    }
    // Error
    else
    {
        Printf("  No Transform Count(%d) or Transform Offset(%d).\n", transformCount, transformOffset);
    }
}
// ==== BOUNDING ==================================================================================
if (boundingEnabled || basicScaling)
{
    // Move
    pos = boundingOffset;
    // Read
    x  = ReadFloat(pos + (floatSize * 0));  // Bounding Box Min X
    y  = ReadFloat(pos + (floatSize * 1));  // Bounding Box Min Y
    z  = ReadFloat(pos + (floatSize * 2));  // Bounding Box Min Z
    x2 = ReadFloat(pos + (floatSize * 3));  // Bounding Box Max X
    y2 = ReadFloat(pos + (floatSize * 4));  // Bounding Box Max Y
    z2 = ReadFloat(pos + (floatSize * 5));  // Bounding Box Max Z
    r  = ReadFloat(pos + (floatSize * 6));  // Bounding Box Radius

    // Output
    if (debug)
    {
        Printf("    Bounding[%d] Offset[0x%X] CURRENT MIN VALUE = (%.6f, %.6f, %.6f)\n",    trackIter, pos, x,  y,  z);
        Printf("    Bounding[%d] Offset[0x%X] CURRENT MAX VALUE = (%.6f, %.6f, %.6f)\n",    trackIter, pos, x2, y2, z2);
        Printf("    Bounding[%d] Offset[0x%X] CURRENT RADIUS VALUE = (%.6f)\n",             trackIter, pos, r);
    }
    // Write
    if (!readOnly)
    {
        WriteFloat(pos + (floatSize * 0), x  * boundingPositionX);
        WriteFloat(pos + (floatSize * 1), y  * boundingPositionY);
        WriteFloat(pos + (floatSize * 2), z  * boundingPositionZ);
        WriteFloat(pos + (floatSize * 3), x2 * boundingPositionX);
        WriteFloat(pos + (floatSize * 4), y2 * boundingPositionY);
        WriteFloat(pos + (floatSize * 5), z2 * boundingPositionZ);
        WriteFloat(pos + (floatSize * 6), r  * boundingPositionR);
        // Output
        if (debug)
        {
            Printf("    Bounding[%d] Offset[0x%X] NEW MIN VALUE = (%.6f, %.6f, %.6f)\n",    trackIter, pos, x,  y,  z);
            Printf("    Bounding[%d] Offset[0x%X] NEW MAX VALUE = (%.6f, %.6f, %.6f)\n",    trackIter, pos, x2, y2, z2);
            Printf("    Bounding[%d] Offset[0x%X] NEW RADIUS VALUE = (%.6f)\n",             trackIter, pos, r);
        }
    }
}
// ==== COLLISION =================================================================================
if (collisionEnabled || basicScaling)
{
    // Move
    pos = boundingOffset; // Collision Box is located in Bounding Box
    // Read
    x  = ReadFloat(pos + (floatSize * 7));  // Collision Box Min X
    y  = ReadFloat(pos + (floatSize * 8));  // Collision Box Min Y
    z  = ReadFloat(pos + (floatSize * 9));  // Collision Box Min Z
    x2 = ReadFloat(pos + (floatSize * 10)); // Collision Box Max X
    y2 = ReadFloat(pos + (floatSize * 11)); // Collision Box Max Y
    z2 = ReadFloat(pos + (floatSize * 12)); // Collision Box Max Z
    r  = ReadFloat(pos + (floatSize * 13)); // Collision Box Radius

    // Output
    if (debug)
    {
        Printf("    Collision Box[%d] Offset[0x%X] CURRENT MIN VALUE = (%.6f, %.6f, %.6f)\n",   trackIter, pos, x,  y,  z);
        Printf("    Collision Box[%d] Offset[0x%X] CURRENT MAX VALUE = (%.6f, %.6f, %.6f)\n",   trackIter, pos, x2, y2, z2);
        Printf("    Collision Box[%d] Offset[0x%X] CURRENT RADIUS VALUE = (%.6f)\n",            trackIter, pos, r);
    }
    // Write
    if (!readOnly)
    {
        WriteFloat(pos + (floatSize * 7),  x  * collisionPositionX);
        WriteFloat(pos + (floatSize * 8),  y  * collisionPositionY);
        WriteFloat(pos + (floatSize * 9),  z  * collisionPositionZ);
        WriteFloat(pos + (floatSize * 10), x2 * collisionPositionX);
        WriteFloat(pos + (floatSize * 11), y2 * collisionPositionY);
        WriteFloat(pos + (floatSize * 12), z2 * collisionPositionZ);
        WriteFloat(pos + (floatSize * 13), r  * collisionPositionR);
        // Output
        if (debug)
        {
            Printf("    Collision Box[%d] Offset[0x%X] NEW MIN VALUE = (%.6f, %.6f, %.6f)\n",   trackIter, pos, x,  y,  z);
            Printf("    Collision Box[%d] Offset[0x%X] NEW MAX VALUE = (%.6f, %.6f, %.6f)\n",   trackIter, pos, x2, y2, z2);
            Printf("    Collision Box[%d] Offset[0x%X] NEW RADIUS VALUE = (%.6f)\n",            trackIter, pos, r);
        }
    }
    // Catch
    if (collisionCount > 0 && collisionOffset > 0)
    {
        // Iterate
        for (trackIter = 0; trackIter < collisionCount; trackIter++)
        {
            // Move
            pos = collisionOffset + (trackIter * collisionSize);
            // Read
            x  = ReadFloat(pos + (floatSize * 0));  // Collision Position X
            y  = ReadFloat(pos + (floatSize * 1));  // Collision Position Y
            z  = ReadFloat(pos + (floatSize * 2));  // Collision Position Z
        
            // Output
            if (debug)
            {
                Printf("    Collision[%d] Offset[0x%X] CURRENT POSITION VALUE = (%.6f, %.6f, %.6f)\n",   trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0),  x  * collisionPositionX);
                WriteFloat(pos + (floatSize * 1),  y  * collisionPositionY);
                WriteFloat(pos + (floatSize * 2),  z  * collisionPositionZ);
                // Output
                if (debug)
                {
                    Printf("    Collision[%d] Offset[0x%X] NEW POSITION VALUE = (%.6f, %.6f, %.6f)\n",   trackIter, pos, x, y, z);
                }
            }
            // Test
            if (testRun)
            {
                Printf("TEST: Collision complete.\n");
                break;
            }
        }
    }
    // Error
    else
    {
        Printf("  No Collision Count(%d) or Collision Offset(%d).\n", collisionCount, collisionOffset);
    }
}
// ==== NORMAL ====================================================================================
if (normalEnabled || basicScaling)
{
    // Catch
    if (normalCount > 0 && normalOffset > 0)
    {
        // Iterate
        for (trackIter = 0; trackIter < normalCount; trackIter++)
        {
            // Move
            pos = normalOffset + (trackIter * normalSize);
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            z = ReadFloat(pos + (floatSize * 2));
            // Output
            if (debug)
            {
                Printf("    Normals[%u] Offset[0x%X] CURRENT POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0), x * normalPositionX);
                WriteFloat(pos + (floatSize * 1), y * normalPositionY);
                WriteFloat(pos + (floatSize * 2), z * normalPositionZ);
                // Output
                if (debug)
                {
                    Printf("    Normals[%u] Offset[0x%X] NEW POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                }
            }
            // Test
            if (testRun)
            {
                Printf("TEST: Normals complete.\n");
                break;
            }
        }
    }
    // Error
    else
    {
        Printf("  No Normal Count(%d) or Normal Offset(%d).\n", normalCount, normalOffset);
    }
}
// ==== ATTACHMENT ================================================================================
if (attachmentEnabled || basicScaling)
{
    // Catch
    if (attachmentCount > 0 && attachmentOffset > 0)
    {
        // Iterate
        for (trackIter = 0; trackIter < attachmentCount; trackIter++)
        {
            // Move
            pos = attachmentOffset + (trackIter * attachmentSize) + attachmentPositionPadding;
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            z = ReadFloat(pos + (floatSize * 2));
            // Output
            if (debug)
            {
                Printf("    Attachment[%u] Offset[0x%X] CURRENT POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0), x * attachmentPositionX);
                WriteFloat(pos + (floatSize * 1), y * attachmentPositionY);
                WriteFloat(pos + (floatSize * 2), z * attachmentPositionZ);
                // Output
                if (debug)
                {
                    Printf("    Attachment[%u] Offset[0x%X] NEW POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                }
            }
            // Test
            if (testRun)
            {
                Printf("TEST: Attachments complete.\n");
                break;
            }
        }
    }
    // Error
    else
    {
        Printf("  No Attachment Count(%d) or Attachment Offset(%d).\n", attachmentCount, attachmentOffset);
    }
}
// ==== EVENTS ====================================================================================
if (eventEnabled || basicScaling)
{
    // Catch
    if (eventCount > 0 && eventOffset > 0)
    {
        // Iterate
        for (trackIter = 0; trackIter < eventCount; trackIter++)
        {
            // Move
            pos = eventOffset + (trackIter * eventSize) + eventPositionPadding;
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            z = ReadFloat(pos + (floatSize * 2));
            // Output
            if (debug)
            {
                Printf("    Event[%u] Offset[0x%X] CURRENT POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0), x * eventPositionX);
                WriteFloat(pos + (floatSize * 1), y * eventPositionY);
                WriteFloat(pos + (floatSize * 2), z * eventPositionZ);
                // Output
                if (debug)
                {
                    Printf("    Event[%u] Offset[0x%X] NEW POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                }
            }
            // Test
            if (testRun)
            {
                Printf("TEST: Events complete.\n");
                break;
            }
        }
    }
    // Error
    else
    {
        Printf("  No Event Count(%d) or Event Offset(%d).\n", eventCount, eventOffset);
    }
}
// ==== LIGHTS ====================================================================================
if (lightEnabled || basicScaling)
{
    // Catch
    if (lightCount > 0 && lightOffset > 0)
    {
        // Iterate
        for (trackIter = 0; trackIter < lightCount; trackIter++)
        {
            // Move
            pos = lightOffset + (trackIter * lightSize) + lightPositionPadding;
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            z = ReadFloat(pos + (floatSize * 2));
            // Output
            if (debug)
            {
                Printf("    Light[%u] Offset[0x%X] CURRENT POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0), x * lightPositionX);
                WriteFloat(pos + (floatSize * 1), y * lightPositionY);
                WriteFloat(pos + (floatSize * 2), z * lightPositionZ);
                // Output
                if (debug)
                {
                    Printf("    Light[%u] Offset[0x%X] NEW POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                }
            }
            // Test
            if (testRun)
            {
                Printf("TEST: Lights complete.\n");
                break;
            }
        }
        // Iterate
        for (blockIter = 0; blockIter < lightCount; blockIter++)
        {
            // Declare
            currentTrack                = lightOffset  + (blockIter * lightSize);
            lightAmbientColorOffset     = currentTrack + lightAmbientColorPadding;
            lightAmbientIntensityOffset = currentTrack + lightAmbientIntensityPadding;
            lightDiffuseColorOffset     = currentTrack + lightDiffuseColorPadding;
            lightDiffuseIntensityOffset = currentTrack + lightDiffuseIntensityPadding;
            lightAttenuationStartOffset = currentTrack + lightAttenuationStartPadding;
            lightAttenuationEndOffset   = currentTrack + lightAttenuationEndPadding;
            lightVisibilityOffset       = currentTrack + lightVisibilityPadding;
            // Output
            if (!silent)
            {
                Printf("\nProcessing Light: %u at 0x%X\n", blockIter, currentTrack);
            }
            // ---- AMBIENT COLOR ----              
            trackInterpolation          =  ReadUShort(lightAmbientColorOffset + 0x00);
            trackGlobalSeq              =   ReadShort(lightAmbientColorOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(lightAmbientColorOffset + 0x04);
                trackRangesOffset       =    ReadUInt(lightAmbientColorOffset + 0x08);
                trackTimestamps         =    ReadUInt(lightAmbientColorOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(lightAmbientColorOffset + 0x10);
                trackKeyPairs           =    ReadUInt(lightAmbientColorOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(lightAmbientColorOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(lightAmbientColorOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(lightAmbientColorOffset + 0x08);
                trackKeyPairs           =    ReadUInt(lightAmbientColorOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(lightAmbientColorOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Ambient Color] Light[%u] @ 0x%X\n",    blockIter, lightAmbientColorOffset);
                Printf("  Interpolation: %u\n",                 trackInterpolation);
                Printf("  Global Seq   : %d\n",                 trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",          trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * vectorSize;                        
                        // Read
                        x = ReadFloat(pos + (floatSize * 0));
                        y = ReadFloat(pos + (floatSize * 1));
                        z = ReadFloat(pos + (floatSize * 2));
                        // Output
                        if (debug) 
                        {
                            Printf("    Light[%u] Current Ambient Color Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos + (floatSize * 0), lightAmbientColorR);
                            WriteFloat(pos + (floatSize * 1), lightAmbientColorG);
                            WriteFloat(pos + (floatSize * 2), lightAmbientColorB);
                            // Output
                            if (debug) 
                            {
                                Printf("    Light[%u] New Ambient Color Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Ambient Color complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * vectorSize);
                                // Read
                                x = ReadFloat(pos + (floatSize * 0));
                                y = ReadFloat(pos + (floatSize * 1));
                                z = ReadFloat(pos + (floatSize * 2));
                                // Output
                                if (debug) 
                                {
                                    Printf("    Light[%u] Current Ambient Color Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos + (floatSize * 0), lightAmbientColorR);
                                    WriteFloat(pos + (floatSize * 1), lightAmbientColorG);
                                    WriteFloat(pos + (floatSize * 2), lightAmbientColorB);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Light[%u] New Ambient Color Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Ambient Color complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- AMBIENT INTENSITY ----              
            trackInterpolation          =  ReadUShort(lightAmbientIntensityOffset + 0x00);
            trackGlobalSeq              =   ReadShort(lightAmbientIntensityOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(lightAmbientIntensityOffset + 0x04);
                trackRangesOffset       =    ReadUInt(lightAmbientIntensityOffset + 0x08);
                trackTimestamps         =    ReadUInt(lightAmbientIntensityOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(lightAmbientIntensityOffset + 0x10);
                trackKeyPairs           =    ReadUInt(lightAmbientIntensityOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(lightAmbientIntensityOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(lightAmbientIntensityOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(lightAmbientIntensityOffset + 0x08);
                trackKeyPairs           =    ReadUInt(lightAmbientIntensityOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(lightAmbientIntensityOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Ambient Intensity] Light[%u] @ 0x%X\n",    blockIter, lightAmbientIntensityOffset);
                Printf("  Interpolation: %u\n",                 trackInterpolation);
                Printf("  Global Seq   : %d\n",                 trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",          trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x = ReadFloat(pos + (floatSize * 0));
                        // Output
                        if (debug) 
                        {
                            Printf("    Light[%u] Current Ambient Intensity Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos + (floatSize * 0), lightAmbientIntensity);
                            // Output
                            if (debug) 
                            {
                                Printf("    Light[%u] New Ambient Intensity Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Ambient Intensity complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x = ReadFloat(pos + (floatSize * 0));
                                // Output
                                if (debug) 
                                {
                                    Printf("    Light[%u] Current Ambient Intensity Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos + (floatSize * 0), lightAmbientIntensity);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Light[%u] New Ambient Intensity Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Ambient Intensity complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- DIFFUSE COLOR ----              
            trackInterpolation          =  ReadUShort(lightDiffuseColorOffset + 0x00);
            trackGlobalSeq              =   ReadShort(lightDiffuseColorOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(lightDiffuseColorOffset + 0x04);
                trackRangesOffset       =    ReadUInt(lightDiffuseColorOffset + 0x08);
                trackTimestamps         =    ReadUInt(lightDiffuseColorOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(lightDiffuseColorOffset + 0x10);
                trackKeyPairs           =    ReadUInt(lightDiffuseColorOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(lightDiffuseColorOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(lightDiffuseColorOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(lightDiffuseColorOffset + 0x08);
                trackKeyPairs           =    ReadUInt(lightDiffuseColorOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(lightDiffuseColorOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Diffuse Color] Light[%u] @ 0x%X\n",    blockIter, lightDiffuseColorOffset);
                Printf("  Interpolation: %u\n",                 trackInterpolation);
                Printf("  Global Seq   : %d\n",                 trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",          trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * vectorSize;                        
                        // Read
                        x = ReadFloat(pos + (floatSize * 0));
                        y = ReadFloat(pos + (floatSize * 1));
                        z = ReadFloat(pos + (floatSize * 2));
                        // Output
                        if (debug) 
                        {
                            Printf("    Light[%u] Current Diffuse Color Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos + (floatSize * 0), lightDiffuseColorR);
                            WriteFloat(pos + (floatSize * 1), lightDiffuseColorG);
                            WriteFloat(pos + (floatSize * 2), lightDiffuseColorB);
                            // Output
                            if (debug) 
                            {
                                Printf("    Light[%u] New Diffuse Color Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Diffuse Color complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * vectorSize);
                                // Read
                                x = ReadFloat(pos + (floatSize * 0));
                                y = ReadFloat(pos + (floatSize * 1));
                                z = ReadFloat(pos + (floatSize * 2));
                                // Output
                                if (debug) 
                                {
                                    Printf("    Light[%u] Current Diffuse Color Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos + (floatSize * 0), lightDiffuseColorR);
                                    WriteFloat(pos + (floatSize * 1), lightDiffuseColorG);
                                    WriteFloat(pos + (floatSize * 2), lightDiffuseColorB);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Light[%u] New Diffuse Color Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Diffuse Color complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- DIFFUSE INTENSITY ----              
            trackInterpolation          =  ReadUShort(lightDiffuseIntensityOffset + 0x00);
            trackGlobalSeq              =   ReadShort(lightDiffuseIntensityOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(lightDiffuseIntensityOffset + 0x04);
                trackRangesOffset       =    ReadUInt(lightDiffuseIntensityOffset + 0x08);
                trackTimestamps         =    ReadUInt(lightDiffuseIntensityOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(lightDiffuseIntensityOffset + 0x10);
                trackKeyPairs           =    ReadUInt(lightDiffuseIntensityOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(lightDiffuseIntensityOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(lightDiffuseIntensityOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(lightDiffuseIntensityOffset + 0x08);
                trackKeyPairs           =    ReadUInt(lightDiffuseIntensityOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(lightDiffuseIntensityOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Diffuse Intensity] Light[%u] @ 0x%X\n",    blockIter, lightDiffuseIntensityOffset);
                Printf("  Interpolation: %u\n",                 trackInterpolation);
                Printf("  Global Seq   : %d\n",                 trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",          trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Light[%u] Current Diffuse Intensity Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, lightDiffuseIntensity);
                            // Output
                            if (debug) 
                            {
                                Printf("    Light[%u] New Diffuse Intensity Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Diffuse Intensity complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Light[%u] Current Diffuse Intensity Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, lightDiffuseColor);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Light[%u] New Diffuse Intensity Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Diffuse Intensity complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- ATTENUATION START ----              
            trackInterpolation          =  ReadUShort(lightAttenuationStartOffset + 0x00);
            trackGlobalSeq              =   ReadShort(lightAttenuationStartOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(lightAttenuationStartOffset + 0x04);
                trackRangesOffset       =    ReadUInt(lightAttenuationStartOffset + 0x08);
                trackTimestamps         =    ReadUInt(lightAttenuationStartOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(lightAttenuationStartOffset + 0x10);
                trackKeyPairs           =    ReadUInt(lightAttenuationStartOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(lightAttenuationStartOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(lightAttenuationStartOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(lightAttenuationStartOffset + 0x08);
                trackKeyPairs           =    ReadUInt(lightAttenuationStartOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(lightAttenuationStartOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Attenuation Start] Light[%u] @ 0x%X\n",    blockIter, lightAttenuationStartOffset);
                Printf("  Interpolation: %u\n",                 trackInterpolation);
                Printf("  Global Seq   : %d\n",                 trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",          trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Light[%u] Current Attenuation Start Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, lightAttenuationStart);
                            // Output
                            if (debug) 
                            {
                                Printf("    Light[%u] New Attenuation Start Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Attenuation Start complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Light[%u] Current Attenuation Start Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, lightAttenuationStart);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Light[%u] New Attenuation Start Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Attenuation Start complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- ATTENUATION END ----              
            trackInterpolation          =  ReadUShort(lightAttenuationEndOffset + 0x00);
            trackGlobalSeq              =   ReadShort(lightAttenuationEndOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(lightAttenuationEndOffset + 0x04);
                trackRangesOffset       =    ReadUInt(lightAttenuationEndOffset + 0x08);
                trackTimestamps         =    ReadUInt(lightAttenuationEndOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(lightAttenuationEndOffset + 0x10);
                trackKeyPairs           =    ReadUInt(lightAttenuationEndOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(lightAttenuationEndOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(lightAttenuationEndOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(lightAttenuationEndOffset + 0x08);
                trackKeyPairs           =    ReadUInt(lightAttenuationEndOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(lightAttenuationEndOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Attenuation End] Light[%u] @ 0x%X\n",  blockIter, lightAttenuationEndOffset);
                Printf("  Interpolation: %u\n",                 trackInterpolation);
                Printf("  Global Seq   : %d\n",                 trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",          trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Light[%u] Current Attenuation End Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, lightAttenuationEnd);
                            // Output
                            if (debug) 
                            {
                                Printf("    Light[%u] New Attenuation End Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Attenuation End complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Light[%u] Current Attenuation End Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, lightAttenuationEnd);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Light[%u] New Attenuation End Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Attenuation End complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- VISIBILITY ----              
            trackInterpolation          =  ReadUShort(lightVisibilityOffset + 0x00);
            trackGlobalSeq              =   ReadShort(lightVisibilityOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(lightVisibilityOffset + 0x04);
                trackRangesOffset       =    ReadUInt(lightVisibilityOffset + 0x08);
                trackTimestamps         =    ReadUInt(lightVisibilityOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(lightVisibilityOffset + 0x10);
                trackKeyPairs           =    ReadUInt(lightVisibilityOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(lightVisibilityOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(lightVisibilityOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(lightVisibilityOffset + 0x08);
                trackKeyPairs           =    ReadUInt(lightVisibilityOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(lightVisibilityOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Visibility] Light[%u] @ 0x%X\n",       blockIter, lightVisibilityOffset);
                Printf("  Interpolation: %u\n",                 trackInterpolation);
                Printf("  Global Seq   : %d\n",                 trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",      trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",      trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",          trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * byteSize;                        
                        // Read
                        x = ReadUByte(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Light[%u] Current Visibility Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%u)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteUByte(pos, x * lightVisibility);
                            // Output
                            if (debug) 
                            {
                                Printf("    Light[%u] New Visibility Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%u)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Visibility complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * byteSize);
                                // Read
                                x = ReadUByte(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Light[%u] Current Visibility Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%u)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteUByte(pos, x * lightVisibility);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Light[%u] New Visibility Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%u)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Visibility complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
        }
    }
    // Error
    else
    {
        Printf("  No Light Count(%d) or Light Offset(%d).\n", lightCount, lightOffset);
    }
}
// ==== CAMERAS ===================================================================================
if (cameraEnabled || basicScaling)
{
    // Catch
    if (cameraCount > 0 && cameraOffset > 0)
    {
        // Iterate
        for (trackIter = 0; trackIter < cameraCount; trackIter++)
        {
            // ---- FOV ----
            pos = cameraOffset + (trackIter * cameraSize) + cameraFovPadding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Camera[%u] Offset[0x%X] CURRENT FOV VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * cameraFov);
                // Output
                if (debug)
                {
                    Printf("    Camera[%u] Offset[0x%X] NEW FOV VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- Near Clip ----
            pos = cameraOffset + (trackIter * cameraSize) + cameraNearclipPadding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Camera[%u] Offset[0x%X] CURRENT NEAR CLIP VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * cameraNearclip);
                // Output
                if (debug)
                {
                    Printf("    Camera[%u] Offset[0x%X] NEW NEAR CLIP VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- Far Clip ----
            pos = cameraOffset + (trackIter * cameraSize) + cameraFarclipPadding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Camera[%u] Offset[0x%X] CURRENT FAR CLIP VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * cameraFarclip);
                // Output
                if (debug)
                {
                    Printf("    Camera[%u] Offset[0x%X] NEW FAR CLIP VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- Position ----
            pos = cameraOffset + (trackIter * cameraSize) + cameraPositionPadding;
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            z = ReadFloat(pos + (floatSize * 2));
            // Output
            if (debug)
            {
                Printf("    Camera[%u] Offset[0x%X] CURRENT POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * cameraPositionX);
                WriteFloat(pos, y * cameraPositionY);
                WriteFloat(pos, z * cameraPositionZ);
                // Output
                if (debug)
                {
                    Printf("    Camera[%u] Offset[0x%X] NEW POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                }
            }
            // ---- Target ----
            pos = cameraOffset + (trackIter * cameraSize) + cameraTargetPadding;
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            z = ReadFloat(pos + (floatSize * 2));
            // Output
            if (debug)
            {
                Printf("    Camera[%u] Offset[0x%X] CURRENT TARGET VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * cameraTargetX);
                WriteFloat(pos, y * cameraTargetY);
                WriteFloat(pos, z * cameraTargetZ);
                // Output
                if (debug)
                {
                    Printf("    Camera[%u] Offset[0x%X] NEW TARGET VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                }
            }
        }
        // Iterate
        for (blockIter = 0; blockIter < cameraCount; blockIter++)
        {
            // Declare
            currentTrack                = cameraOffset + (blockIter * cameraSize);
            cameraTranslationPosOffset  = currentTrack + cameraTranslationPosPadding;
            cameraTranslationTarOffset  = currentTrack + cameraTranslationTarPadding;
            cameraRollOffset            = currentTrack + cameraRollPadding;
            // Output
            if (!silent)
            {
                Printf("\nProcessing Camera: %u at 0x%X\n", blockIter, currentTrack);
            }
            // ---- TRANSLATION POSITION ----              
            trackInterpolation          =  ReadUShort(cameraTranslationPosOffset + 0x00);
            trackGlobalSeq              =   ReadShort(cameraTranslationPosOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(cameraTranslationPosOffset + 0x04);
                trackRangesOffset       =    ReadUInt(cameraTranslationPosOffset + 0x08);
                trackTimestamps         =    ReadUInt(cameraTranslationPosOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(cameraTranslationPosOffset + 0x10);
                trackKeyPairs           =    ReadUInt(cameraTranslationPosOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(cameraTranslationPosOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(cameraTranslationPosOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(cameraTranslationPosOffset + 0x08);
                trackKeyPairs           =    ReadUInt(cameraTranslationPosOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(cameraTranslationPosOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Translation Position] Camera[%u] @ 0x%X\n",    blockIter, cameraTranslationPosOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * (vectorSize * 3);                        
                        // Read
                        x  = ReadFloat(pos + (floatSize * 0));
                        y  = ReadFloat(pos + (floatSize * 1));
                        z  = ReadFloat(pos + (floatSize * 2));
                        x2 = ReadFloat(pos + (floatSize * 3));
                        y2 = ReadFloat(pos + (floatSize * 4));
                        z2 = ReadFloat(pos + (floatSize * 5));
                        x3 = ReadFloat(pos + (floatSize * 6));
                        y3 = ReadFloat(pos + (floatSize * 7));
                        z3 = ReadFloat(pos + (floatSize * 8));
                        // Output
                        if (debug) 
                        {
                            Printf("    Camera[%u] Current Translation Position Value[%d] @ 0x%X\n", blockIter, trackIter, pos);
                            Printf("Point  = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                            Printf("TanIn  = (%.6f, %.6f, %.6f)\n", x2, y2, z2);
                            Printf("TanOut = (%.6f, %.6f, %.6f)\n", x3, y3, z3);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos + (floatSize * 0), x  * cameraTranslationPosPointX);
                            WriteFloat(pos + (floatSize * 1), y  * cameraTranslationPosPointY);
                            WriteFloat(pos + (floatSize * 2), z  * cameraTranslationPosPointZ);
                            WriteFloat(pos + (floatSize * 3), x2 * cameraTranslationPosTanInX);
                            WriteFloat(pos + (floatSize * 4), y2 * cameraTranslationPosTanInY);
                            WriteFloat(pos + (floatSize * 5), z2 * cameraTranslationPosTanInZ);
                            WriteFloat(pos + (floatSize * 6), x3 * cameraTranslationPosTanOutX);
                            WriteFloat(pos + (floatSize * 7), y3 * cameraTranslationPosTanOutY);
                            WriteFloat(pos + (floatSize * 8), z3 * cameraTranslationPosTanOutZ);
                            // Output
                            if (debug) 
                            {
                                Printf("    Camera[%u] New Translation Position Value[%d] @ 0x%X\n", blockIter, trackIter, pos);
                                Printf("Point  = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                                Printf("TanIn  = (%.6f, %.6f, %.6f)\n", x2, y2, z2);
                                Printf("TanOut = (%.6f, %.6f, %.6f)\n", x3, y3, z3);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Translation Position complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * (vectorSize * 3));
                                // Read
                                x  = ReadFloat(pos + (floatSize * 0));
                                y  = ReadFloat(pos + (floatSize * 1));
                                z  = ReadFloat(pos + (floatSize * 2));
                                x2 = ReadFloat(pos + (floatSize * 3));
                                y2 = ReadFloat(pos + (floatSize * 4));
                                z2 = ReadFloat(pos + (floatSize * 5));
                                x3 = ReadFloat(pos + (floatSize * 6));
                                y3 = ReadFloat(pos + (floatSize * 7));
                                z3 = ReadFloat(pos + (floatSize * 8));
                                // Output
                                if (debug) 
                                {
                                    Printf("    Camera[%u] Current Translation Position Value[%d] Subtrack[%d] @ 0x%X\n", blockIter, trackIter, subIter, pos);
                                    Printf("Point  = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                                    Printf("TanIn  = (%.6f, %.6f, %.6f)\n", x2, y2, z2);
                                    Printf("TanOut = (%.6f, %.6f, %.6f)\n", x3, y3, z3);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos + (floatSize * 0), x  * cameraTranslationPosPointX);
                                    WriteFloat(pos + (floatSize * 1), y  * cameraTranslationPosPointY);
                                    WriteFloat(pos + (floatSize * 2), z  * cameraTranslationPosPointZ);
                                    WriteFloat(pos + (floatSize * 3), x2 * cameraTranslationPosTanInX);
                                    WriteFloat(pos + (floatSize * 4), y2 * cameraTranslationPosTanInY);
                                    WriteFloat(pos + (floatSize * 5), z2 * cameraTranslationPosTanInZ);
                                    WriteFloat(pos + (floatSize * 6), x3 * cameraTranslationPosTanOutX);
                                    WriteFloat(pos + (floatSize * 7), y3 * cameraTranslationPosTanOutY);
                                    WriteFloat(pos + (floatSize * 8), z3 * cameraTranslationPosTanOutZ);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Camera[%u] New Translation Position Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf("Point  = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                                        Printf("TanIn  = (%.6f, %.6f, %.6f)\n", x2, y2, z2);
                                        Printf("TanOut = (%.6f, %.6f, %.6f)\n", x3, y3, z3);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Translation Position complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- TRANSLATION TARGET ----              
            trackInterpolation          =  ReadUShort(cameraTranslationTarOffset + 0x00);
            trackGlobalSeq              =   ReadShort(cameraTranslationTarOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(cameraTranslationTarOffset + 0x04);
                trackRangesOffset       =    ReadUInt(cameraTranslationTarOffset + 0x08);
                trackTimestamps         =    ReadUInt(cameraTranslationTarOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(cameraTranslationTarOffset + 0x10);
                trackKeyPairs           =    ReadUInt(cameraTranslationTarOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(cameraTranslationTarOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(cameraTranslationTarOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(cameraTranslationTarOffset + 0x08);
                trackKeyPairs           =    ReadUInt(cameraTranslationTarOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(cameraTranslationTarOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Translation Target] Camera[%u] @ 0x%X\n",      blockIter, cameraTranslationTarOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * (vectorSize * 3);                        
                        // Read
                        x  = ReadFloat(pos + (floatSize * 0));
                        y  = ReadFloat(pos + (floatSize * 1));
                        z  = ReadFloat(pos + (floatSize * 2));
                        x2 = ReadFloat(pos + (floatSize * 3));
                        y2 = ReadFloat(pos + (floatSize * 4));
                        z2 = ReadFloat(pos + (floatSize * 5));
                        x3 = ReadFloat(pos + (floatSize * 6));
                        y3 = ReadFloat(pos + (floatSize * 7));
                        z3 = ReadFloat(pos + (floatSize * 8));
                        // Output
                        if (debug) 
                        {
                            Printf("    Camera[%u] Current Translation Target Value[%d] @ 0x%X\n", blockIter, trackIter, pos);
                            Printf("Point  = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                            Printf("TanIn  = (%.6f, %.6f, %.6f)\n", x2, y2, z2);
                            Printf("TanOut = (%.6f, %.6f, %.6f)\n", x3, y3, z3);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos + (floatSize * 0), x  * cameraTranslationTarPointX);
                            WriteFloat(pos + (floatSize * 1), y  * cameraTranslationTarPointY);
                            WriteFloat(pos + (floatSize * 2), z  * cameraTranslationTarPointZ);
                            WriteFloat(pos + (floatSize * 3), x2 * cameraTranslationTarTanInX);
                            WriteFloat(pos + (floatSize * 4), y2 * cameraTranslationTarTanInY);
                            WriteFloat(pos + (floatSize * 5), z2 * cameraTranslationTarTanInZ);
                            WriteFloat(pos + (floatSize * 6), x3 * cameraTranslationTarTanOutX);
                            WriteFloat(pos + (floatSize * 7), y3 * cameraTranslationTarTanOutY);
                            WriteFloat(pos + (floatSize * 8), z3 * cameraTranslationTarTanOutZ);
                            // Output
                            if (debug) 
                            {
                                Printf("    Camera[%u] New Translation Position Value[%d] @ 0x%X\n", blockIter, trackIter, pos);
                                Printf("Point  = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                                Printf("TanIn  = (%.6f, %.6f, %.6f)\n", x2, y2, z2);
                                Printf("TanOut = (%.6f, %.6f, %.6f)\n", x3, y3, z3);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Translation Position complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * (vectorSize * 3));
                                // Read
                                x  = ReadFloat(pos + (floatSize * 0));
                                y  = ReadFloat(pos + (floatSize * 1));
                                z  = ReadFloat(pos + (floatSize * 2));
                                x2 = ReadFloat(pos + (floatSize * 3));
                                y2 = ReadFloat(pos + (floatSize * 4));
                                z2 = ReadFloat(pos + (floatSize * 5));
                                x3 = ReadFloat(pos + (floatSize * 6));
                                y3 = ReadFloat(pos + (floatSize * 7));
                                z3 = ReadFloat(pos + (floatSize * 8));
                                // Output
                                if (debug) 
                                {
                                    Printf("    Camera[%u] Current Translation Target Value[%d] Subtrack[%d] @ 0x%X\n", blockIter, trackIter, subIter, pos);
                                    Printf("Point  = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                                    Printf("TanIn  = (%.6f, %.6f, %.6f)\n", x2, y2, z2);
                                    Printf("TanOut = (%.6f, %.6f, %.6f)\n", x3, y3, z3);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos + (floatSize * 0), x  * cameraTranslationTarPointX);
                                    WriteFloat(pos + (floatSize * 1), y  * cameraTranslationTarPointY);
                                    WriteFloat(pos + (floatSize * 2), z  * cameraTranslationTarPointZ);
                                    WriteFloat(pos + (floatSize * 3), x2 * cameraTranslationTarTanInX);
                                    WriteFloat(pos + (floatSize * 4), y2 * cameraTranslationTarTanInY);
                                    WriteFloat(pos + (floatSize * 5), z2 * cameraTranslationTarTanInZ);
                                    WriteFloat(pos + (floatSize * 6), x3 * cameraTranslationTarTanOutX);
                                    WriteFloat(pos + (floatSize * 7), y3 * cameraTranslationTarTanOutY);
                                    WriteFloat(pos + (floatSize * 8), z3 * cameraTranslationTarTanOutZ);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Camera[%u] New Translation Target Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf("Point  = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                                        Printf("TanIn  = (%.6f, %.6f, %.6f)\n", x2, y2, z2);
                                        Printf("TanOut = (%.6f, %.6f, %.6f)\n", x3, y3, z3);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Translation Target complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- ROLL EFFECT ----              
            trackInterpolation          =  ReadUShort(cameraRollOffset + 0x00);
            trackGlobalSeq              =   ReadShort(cameraRollOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(cameraRollOffset + 0x04);
                trackRangesOffset       =    ReadUInt(cameraRollOffset + 0x08);
                trackTimestamps         =    ReadUInt(cameraRollOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(cameraRollOffset + 0x10);
                trackKeyPairs           =    ReadUInt(cameraRollOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(cameraRollOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(cameraRollOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(cameraRollOffset + 0x08);
                trackKeyPairs           =    ReadUInt(cameraRollOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(cameraRollOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Roll Effect] Camera[%u] @ 0x%X\n",    blockIter, cameraRollOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * vectorSize;                        
                        // Read
                        x  = ReadFloat(pos + (floatSize * 0));
                        y  = ReadFloat(pos + (floatSize * 1));
                        z  = ReadFloat(pos + (floatSize * 2));
                        // Output
                        if (debug) 
                        {
                            Printf("    Camera[%u] Current Roll Effect Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos + (floatSize * 0), x  * cameraRollX);
                            WriteFloat(pos + (floatSize * 1), y  * cameraRollY);
                            WriteFloat(pos + (floatSize * 2), z  * cameraRollZ);
                            // Output
                            if (debug) 
                            {
                                Printf("    Camera[%u] New Roll Effect Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Roll Effect complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * vectorSize);
                                // Read
                                x  = ReadFloat(pos + (floatSize * 0));
                                y  = ReadFloat(pos + (floatSize * 1));
                                z  = ReadFloat(pos + (floatSize * 2));
                                // Output
                                if (debug) 
                                {
                                    Printf("    Camera[%u] Current Roll Effect Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos + (floatSize * 0), x  * cameraRollX);
                                    WriteFloat(pos + (floatSize * 1), y  * cameraRollY);
                                    WriteFloat(pos + (floatSize * 2), z  * cameraRollZ);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Camera[%u] New Roll Effect Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Roll Effect complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
        }
    }
    // Error
    else
    {
        Printf("  No Camera Count(%d) or Camera Offset(%d).\n", cameraCount, cameraOffset);
    }
}
// ==== RIBBON ====================================================================================
if (ribbonEnabled || basicScaling)
{
    // Catch
    if (ribbonCount > 0 && ribbonOffset > 0)
    {
        // Iterate
        for (trackIter = 0; trackIter < ribbonCount; trackIter++)
        {
            // ---- POSITION ----
            pos = ribbonOffset + (trackIter * ribbonSize) + ribbonPositionPadding;
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            z = ReadFloat(pos + (floatSize * 2));
            // Output
            if (debug)
            {
                Printf("    Ribbon[%u] Offset[0x%X] CURRENT POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0), x * ribbonPositionX);
                WriteFloat(pos + (floatSize * 1), y * ribbonPositionY);
                WriteFloat(pos + (floatSize * 2), z * ribbonPositionZ);
                // Output
                if (debug)
                {
                    Printf("    Ribbon[%u] Offset[0x%X] NEW POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                }
            }
            // ---- EDGE RATE ----
            pos = ribbonOffset + (trackIter * ribbonSize) + ribbonEdgeRatePadding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Ribbon[%u] Offset[0x%X] CURRENT EDGE RATE VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * ribbonEdgeRate);
                // Output
                if (debug)
                {
                    Printf("    Ribbon[%u] Offset[0x%X] NEW EDGE RATE VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- EDGE LIFESPAN ----
            pos = ribbonOffset + (trackIter * ribbonSize) + ribbonEdgeLifespanPadding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Ribbon[%u] Offset[0x%X] CURRENT EDGE LIFESPAN VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * ribbonEdgeLifespan);
                // Output
                if (debug)
                {
                    Printf("    Ribbon[%u] Offset[0x%X] NEW EDGE LIFESPAN VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- GRAVITY ----
            pos = ribbonOffset + (trackIter * ribbonSize) + ribbonGravityPadding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Ribbon[%u] Offset[0x%X] CURRENT GRAVITY VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * ribbonGravity);
                // Output
                if (debug)
                {
                    Printf("    Ribbon[%u] Offset[0x%X] NEW GRAVITY VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
        }
        // Iterate
        for (blockIter = 0; blockIter < ribbonCount; blockIter++)
        {
            // Declare
            currentTrack                = ribbonOffset + (blockIter * ribbonSize);
            ribbonColorOffset           = currentTrack + ribbonColorPadding;
            ribbonAlphaOffset           = currentTrack + ribbonAlphaPadding;
            ribbonHeightAboveOffset     = currentTrack + ribbonHeightAbovePadding;
            ribbonHeightBelowOffset     = currentTrack + ribbonHeightBelowPadding;
            ribbonVisibilityOffset      = currentTrack + ribbonVisibilityPadding;
            // Output
            if (!silent)
            {
                Printf("\nProcessing Ribbon: %u at 0x%X\n", blockIter, currentTrack);
            }
            // ---- COLOR ----              
            trackInterpolation          =  ReadUShort(ribbonColorOffset + 0x00);
            trackGlobalSeq              =   ReadShort(ribbonColorOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(ribbonColorOffset + 0x04);
                trackRangesOffset       =    ReadUInt(ribbonColorOffset + 0x08);
                trackTimestamps         =    ReadUInt(ribbonColorOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(ribbonColorOffset + 0x10);
                trackKeyPairs           =    ReadUInt(ribbonColorOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(ribbonColorOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(ribbonColorOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(ribbonColorOffset + 0x08);
                trackKeyPairs           =    ReadUInt(ribbonColorOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(ribbonColorOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Color] Ribbon[%u] @ 0x%X\n",                   blockIter, ribbonColorOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * vectorSize;                        
                        // Read
                        x  = ReadFloat(pos + (floatSize * 0));
                        y  = ReadFloat(pos + (floatSize * 1));
                        z  = ReadFloat(pos + (floatSize * 2));
                        // Output
                        if (debug) 
                        {
                            Printf("    Ribbon[%u] Current Color Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos + (floatSize * 0), x  * ribbonColorR);
                            WriteFloat(pos + (floatSize * 1), y  * ribbonColorG);
                            WriteFloat(pos + (floatSize * 2), z  * ribbonColorB);
                            // Output
                            if (debug) 
                            {
                                Printf("    Ribbon[%u] New Color Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Ribbon Color complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * vectorSize);
                                // Read
                                x  = ReadFloat(pos + (floatSize * 0));
                                y  = ReadFloat(pos + (floatSize * 1));
                                z  = ReadFloat(pos + (floatSize * 2));
                                // Output
                                if (debug) 
                                {
                                    Printf("    Ribbon[%u] Current Color Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos + (floatSize * 0), x  * ribbonColorR);
                                    WriteFloat(pos + (floatSize * 1), y  * ribbonColorG);
                                    WriteFloat(pos + (floatSize * 2), z  * ribbonColorB);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Ribbon[%u] New Color Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f, %.6f, %.6f)\n", x,  y,  z);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Color complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- ALPHA ----              
            trackInterpolation          =  ReadUShort(ribbonAlphaOffset + 0x00);
            trackGlobalSeq              =   ReadShort(ribbonAlphaOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(ribbonAlphaOffset + 0x04);
                trackRangesOffset       =    ReadUInt(ribbonAlphaOffset + 0x08);
                trackTimestamps         =    ReadUInt(ribbonAlphaOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(ribbonAlphaOffset + 0x10);
                trackKeyPairs           =    ReadUInt(ribbonAlphaOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(ribbonAlphaOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(ribbonAlphaOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(ribbonAlphaOffset + 0x08);
                trackKeyPairs           =    ReadUInt(ribbonAlphaOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(ribbonAlphaOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Ribbon Alpha] Ribbon[%u] @ 0x%X\n",            blockIter, ribbonAlphaOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Move
                    pos = trackKeyPairsOffset + trackIter * shortSize;                        
                    // Read
                    x  = ReadShort(pos);
                    // Output
                    if (debug) 
                    {
                        Printf("    Ribbon[%u] Current Alpha Value[%d] @ 0x%X", blockIter, trackIter, pos);
                        Printf(" = (%u)\n", x);
                    }
                    // Write
                    if (!readOnly)
                    {
                        // Write
                        WriteShort(pos, x  * ribbonAlpha);
                        // Output
                        if (debug) 
                        {
                            Printf("    Ribbon[%u] New Alpha Value[%d] @ 0x%X\n", blockIter, trackIter, pos);
                            Printf(" = (%u)\n", x);
                        }
                    }
                    // Test
                    if (testRun)
                    {
                        Printf("TEST: Alpha complete.\n");
                        break;
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- HEIGHT ABOVE ----              
            trackInterpolation          =  ReadUShort(ribbonHeightAboveOffset + 0x00);
            trackGlobalSeq              =   ReadShort(ribbonHeightAboveOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(ribbonHeightAboveOffset + 0x04);
                trackRangesOffset       =    ReadUInt(ribbonHeightAboveOffset + 0x08);
                trackTimestamps         =    ReadUInt(ribbonHeightAboveOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(ribbonHeightAboveOffset + 0x10);
                trackKeyPairs           =    ReadUInt(ribbonHeightAboveOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(ribbonHeightAboveOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(ribbonHeightAboveOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(ribbonHeightAboveOffset + 0x08);
                trackKeyPairs           =    ReadUInt(ribbonHeightAboveOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(ribbonHeightAboveOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Height Above] Ribbon[%u] @ 0x%X\n",            blockIter, ribbonHeightAboveOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Ribbon[%u] Current Height Above Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x  * ribbonHeightAbove);
                            // Output
                            if (debug) 
                            {
                                Printf("    Ribbon[%u] New Height Above Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Height Below complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Ribbon[%u] Current Height Above Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x  * ribbonHeightAbove);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Ribbon[%u] New Height Above Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Height Above complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- HEIGHT BELOW ----              
            trackInterpolation          =  ReadUShort(ribbonHeightBelowOffset + 0x00);
            trackGlobalSeq              =   ReadShort(ribbonHeightBelowOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(ribbonHeightBelowOffset + 0x04);
                trackRangesOffset       =    ReadUInt(ribbonHeightBelowOffset + 0x08);
                trackTimestamps         =    ReadUInt(ribbonHeightBelowOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(ribbonHeightBelowOffset + 0x10);
                trackKeyPairs           =    ReadUInt(ribbonHeightBelowOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(ribbonHeightBelowOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(ribbonHeightBelowOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(ribbonHeightBelowOffset + 0x08);
                trackKeyPairs           =    ReadUInt(ribbonHeightBelowOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(ribbonHeightBelowOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Height Below] Ribbon[%u] @ 0x%X\n",            blockIter, ribbonHeightBelowOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Ribbon[%u] Current Height Below Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x  * ribbonHeightBelow);
                            // Output
                            if (debug) 
                            {
                                Printf("    Ribbon[%u] New Height Below Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Height Below complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Ribbon[%u] Current Height Below Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x  * ribbonHeightBelow);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Ribbon[%u] New Height Below Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Height Below complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- VISIBILITY ----              
            trackInterpolation          =  ReadUShort(ribbonVisibilityOffset + 0x00);
            trackGlobalSeq              =   ReadShort(ribbonVisibilityOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(ribbonVisibilityOffset + 0x04);
                trackRangesOffset       =    ReadUInt(ribbonVisibilityOffset + 0x08);
                trackTimestamps         =    ReadUInt(ribbonVisibilityOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(ribbonVisibilityOffset + 0x10);
                trackKeyPairs           =    ReadUInt(ribbonVisibilityOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(ribbonVisibilityOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(ribbonVisibilityOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(ribbonVisibilityOffset + 0x08);
                trackKeyPairs           =    ReadUInt(ribbonVisibilityOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(ribbonVisibilityOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Visibility] Ribbon[%u] @ 0x%X\n",              blockIter, ribbonVisibilityOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * byteSize;                        
                        // Read
                        x  = ReadByte(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Ribbon[%u] Current Visibility Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%i)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteByte(pos, x  * ribbonVisibility);
                            // Output
                            if (debug) 
                            {
                                Printf("    Ribbon[%u] New Visibility Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%i)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Visibility complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * byteSize);
                                // Read
                                x  = ReadByte(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Ribbon[%u] Current Visibility Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%i)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteByte(pos, x  * ribbonVisibility);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Ribbon[%u] New Visibility Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%i)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Visibility complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
        }
    }
    // Error
    else
    {
        Printf("  No Ribbon Count(%d) or Ribbon Offset(%d).\n", ribbonCount, ribbonOffset);
    }
}
// ==== PARTICLE ==================================================================================
if (particleEnabled || basicScaling)
{
    // Catch
    if (particleCount > 0 && particleOffset > 0)
    {
        // Iterate
        for (trackIter = 0; trackIter < particleCount; trackIter++)
        {
            // ---- POSITION ----
            pos = particleOffset + (trackIter * particleSize) + particlePositionPadding;
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            z = ReadFloat(pos + (floatSize * 2));
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0), x * particlePositionX);
                WriteFloat(pos + (floatSize * 1), y * particlePositionY);
                WriteFloat(pos + (floatSize * 2), z * particlePositionZ);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW POSITION VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                }
            }
            // ---- LIFESPAN VARY ----
            // Wrath of the Lich King and higher
            if (expansion >= 3)
            {
                pos = particleOffset + (trackIter * particleSize) + particleLifespanVaryPadding;
                // Read
                x = ReadFloat(pos);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] CURRENT LIFESPAN VARY VALUE = (%.6f)\n", trackIter, pos, x);
                }
                // Write
                if (!readOnly)
                {
                    WriteFloat(pos, x * particleLifespanVary);
                    // Output
                    if (debug)
                    {
                        Printf("    Particle[%u] Offset[0x%X] NEW LIFESPAN VARY VALUE = (%.6f)\n", trackIter, pos, x);
                    }
                }
            }
            // ---- EMISSION RATE VARY ----
            // Wrath of the Lich King and higher
            if (expansion >= 3)
            {
                pos = particleOffset + (trackIter * particleSize) + particleEmissionRateVaryPadding;
                // Read
                x = ReadFloat(pos);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] CURRENT EMISSION RATE VALUE = (%.6f)\n", trackIter, pos, x);
                }
                // Write
                if (!readOnly)
                {
                    WriteFloat(pos, x * particleEmissionRateVary);
                    // Output
                    if (debug)
                    {
                        Printf("    Particle[%u] Offset[0x%X] NEW EMISSION RATE VALUE = (%.6f)\n", trackIter, pos, x);
                    }
                }
            }
            // ---- MID POINT ----
            // The Burning Crusade and lower
            if (expansion <= 2)
            {
                pos = particleOffset + (trackIter * particleSize) + particleMidpointPadding;
                // Read
                x = ReadFloat(pos);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] CURRENT MID POINT VALUE = (%.6f)\n", trackIter, pos, x);
                }
                // Write
                if (!readOnly)
                {
                    WriteFloat(pos, x * particleMidpoint);
                    // Output
                    if (debug)
                    {
                        Printf("    Particle[%u] Offset[0x%X] NEW MID POINT VALUE = (%.6f)\n", trackIter, pos, x);
                    }
                }
            }
            // ---- COLOR ----
            // The Burning Crusade and lower
            if (expansion <= 2)
            {
                pos = particleOffset + (trackIter * particleSize) + particleColorPadding;
                // Read
                x = ReadByte(pos + (byteSize * 0));
                y = ReadByte(pos + (byteSize * 1));
                z = ReadByte(pos + (byteSize * 2));
                w = ReadByte(pos + (byteSize * 3));
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] CURRENT COLOR VALUE = (%u, %u, %u, %u)\n", trackIter, pos, x, y, z, w);
                }
                // Write
                if (!readOnly)
                {
                    WriteByte(pos + (byteSize * 0), x * particleColorByteR);
                    WriteByte(pos + (byteSize * 1), y * particleColorByteG);
                    WriteByte(pos + (byteSize * 2), z * particleColorByteB);
                    WriteByte(pos + (byteSize * 2), w * particleColorByteA);
                    // Output
                    if (debug)
                    {
                        Printf("    Particle[%u] Offset[0x%X] NEW COLOR VALUE = (%u, %u, %u, %u)\n", trackIter, pos, x, y, z, w);
                    }
                }
            }
            // ---- SCALE ----
            // The Burning Crusade and lower
            if (expansion <= 2)
            {
                pos = particleOffset + (trackIter * particleSize) + particleScalePadding;
                // Read
                x = ReadFloat(pos + (floatSize * 0));
                y = ReadFloat(pos + (floatSize * 1));
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] CURRENT SCALE VALUE = (%.6f, %.6f)\n", trackIter, pos, x, y);
                }
                // Write
                if (!readOnly)
                {
                    WriteFloat(pos, x * particleScaleX);
                    WriteFloat(pos, y * particleScaleY);
                    // Output
                    if (debug)
                    {
                        Printf("    Particle[%u] Offset[0x%X] NEW SCALE VALUE = (%.6f, %.6f)\n", trackIter, pos, x, y);
                    }
                }
            }
            // ---- SCALE VARY ----
            // Wrath of the Lich King and higher
            if (expansion >= 3)
            {
                pos = particleOffset + (trackIter * particleSize) + particleScaleVaryPadding;
                // Read
                x = ReadFloat(pos + (floatSize * 0));
                y = ReadFloat(pos + (floatSize * 1));
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] CURRENT SCALE VARY VALUE = (%.6f, %.6f)\n", trackIter, pos, x, y);
                }
                // Write
                if (!readOnly)
                {
                    WriteFloat(pos + (floatSize * 0), x * particleScaleVaryX);
                    WriteFloat(pos + (floatSize * 1), y * particleScaleVaryY);
                    // Output
                    if (debug)
                    {
                        Printf("    Particle[%u] Offset[0x%X] NEW POSITION VALUE = (%.6f, %.6f)\n", trackIter, pos, x, y);
                    }
                }
            }
            // ---- TAIL LENGTH ----
            pos = particleOffset + (trackIter * particleSize) + particleTailLengthPadding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT TAIL LENGTH VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * particleTailLength);

                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW TAIL LENGTH VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- TWINKLE SPEED ----
            pos = particleOffset + (trackIter * particleSize) + particleTwinkleSpeedPadding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT TWINKLE SPEED VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * particleTwinkleSpeed);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW TWINKLE SPEED VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- TWINKLE PERCENT ----
            pos = particleOffset + (trackIter * particleSize) + particleTwinklePercentPadding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT TWINKLE PERCENT VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * particleTwinklePercent);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW TWINKLE PERCENT VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- TWINKLE SCALE ----
            pos = particleOffset + (trackIter * particleSize) + particleTwinkleScalePadding;
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT TWINKLE SCALE VALUE = (%.6f, %.6f)\n", trackIter, pos, x, y);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0), x * particleTwinkleScaleX);
                WriteFloat(pos + (floatSize * 1), y * particleTwinkleScaleY);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW TWINKLE SCALE VALUE = (%.6f, %.6f)\n", trackIter, pos, x, y);
                }
            }
            // ---- BURST MULTIPLIER ----
            pos = particleOffset + (trackIter * particleSize) + particleBurstPadding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT BURST MULTIPLIER VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * particleBurst);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW BURST MULTIPLIER VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- DRAG ----
            pos = particleOffset + (trackIter * particleSize) + particleDragPadding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT DRAG VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * particleDrag);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW DRAG VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- BASE SPIN ----
            // Wrath of the Lich King and higher
            if (expansion >= 3)
            {
                pos = particleOffset + (trackIter * particleSize) + particleBaseSpinPadding;
                // Read
                x = ReadFloat(pos);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] CURRENT BASE SPIN VALUE = (%.6f)\n", trackIter, pos, x);
                }
                // Write
                if (!readOnly)
                {
                    WriteFloat(pos, x * particleBaseSpin);
                    // Output
                    if (debug)
                    {
                        Printf("    Particle[%u] Offset[0x%X] NEW BASE SPIN VALUE = (%.6f)\n", trackIter, pos, x);
                    }
                }
            }
            // ---- BASE SPIN VARY ----
            // Wrath of the Lich King and higher
            if (expansion >= 3)
            {
                pos = particleOffset + (trackIter * particleSize) + particleBaseSpinVaryPadding;
                // Read
                x = ReadFloat(pos);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] CURRENT BASE SPIN VARY VALUE = (%.6f)\n", trackIter, pos, x);
                }
                // Write
                if (!readOnly)
                {
                    WriteFloat(pos, x * particleBaseSpinVary);
                    // Output
                    if (debug)
                    {
                        Printf("    Particle[%u] Offset[0x%X] NEW BASE SPIN VARY VALUE = (%.6f)\n", trackIter, pos, x);
                    }
                }
            }
            // ---- SPIN ----
            pos = particleOffset + (trackIter * particleSize) + particleSpinPadding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT SPIN VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * particleSpin);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW SPIN VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- SPIN VARY ----
            // Wrath of the Lich King and higher
            if (expansion >= 3)
            {
                pos = particleOffset + (trackIter * particleSize) + particleSpinVaryPadding;
                // Read
                x = ReadFloat(pos);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] CURRENT SPIN VARY VALUE = (%.6f)\n", trackIter, pos, x);
                }
                // Write
                if (!readOnly)
                {
                    WriteFloat(pos, x * particleSpinVary);
                    // Output
                    if (debug)
                    {
                        Printf("    Particle[%u] Offset[0x%X] NEW SPIN VARY VALUE = (%.6f)\n", trackIter, pos, x);
                    }
                }
            }
            // ---- TUMBLE MIN ----
            pos = particleOffset + (trackIter * particleSize) + particleTumbleMinPadding;
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            z = ReadFloat(pos + (floatSize * 2));
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT TUMBLE MIN VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0), x * particleTumbleMinX);
                WriteFloat(pos + (floatSize * 1), y * particleTumbleMinY);
                WriteFloat(pos + (floatSize * 2), z * particleTumbleMinZ);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW TUMBLE MIN VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                }
            }
            // ---- TUMBLE MAX ----
            pos = particleOffset + (trackIter * particleSize) + particleTumbleMaxPadding;
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            z = ReadFloat(pos + (floatSize * 2));
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT TUMBLE MAX VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0), x * particleTumbleMaxX);
                WriteFloat(pos + (floatSize * 1), y * particleTumbleMaxY);
                WriteFloat(pos + (floatSize * 2), z * particleTumbleMaxZ);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW TUMBLE MAX VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                }
            }
            // ---- WIND VECTOR ----
            pos = particleOffset + (trackIter * particleSize) + particleWindVectorPadding;
            // Read
            x = ReadFloat(pos + (floatSize * 0));
            y = ReadFloat(pos + (floatSize * 1));
            z = ReadFloat(pos + (floatSize * 2));
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT WIND VECTOR VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos + (floatSize * 0), x * particleWindVectorX);
                WriteFloat(pos + (floatSize * 1), y * particleWindVectorY);
                WriteFloat(pos + (floatSize * 2), z * particleWindVectorZ);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW WIND VECTOR VALUE = (%.6f, %.6f, %.6f)\n", trackIter, pos, x, y, z);
                }
            }
            // ---- WIND TIME ----
            pos = particleOffset + (trackIter * particleSize) + particleWindTimePadding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT WIND TIME VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * particleWindTime);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW WIND TIME VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- FOLLOW SPEED1 ----
            pos = particleOffset + (trackIter * particleSize) + particleFollowSpeed1Padding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT FOLLOW SPEED1 VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * particleFollowSpeed1);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW FOLLOW SPEED1 VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- FOLLOW SCALE1 ----
            pos = particleOffset + (trackIter * particleSize) + particleFollowScale1Padding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT FOLLOW SCALE1 VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * particleFollowScale1);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW FOLLOW SCALE1 VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- FOLLOW SPEED2 ----
            pos = particleOffset + (trackIter * particleSize) + particleFollowSpeed2Padding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT FOLLOW SPEED2 VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * particleFollowSpeed2);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW FOLLOW SPEED2 VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // ---- FOLLOW SCALE2 ----
            pos = particleOffset + (trackIter * particleSize) + particleFollowScale2Padding;
            // Read
            x = ReadFloat(pos);
            // Output
            if (debug)
            {
                Printf("    Particle[%u] Offset[0x%X] CURRENT FOLLOW SCALE2 VALUE = (%.6f)\n", trackIter, pos, x);
            }
            // Write
            if (!readOnly)
            {
                WriteFloat(pos, x * particleFollowScale2);
                // Output
                if (debug)
                {
                    Printf("    Particle[%u] Offset[0x%X] NEW FOLLOW SCALE2 VALUE = (%.6f)\n", trackIter, pos, x);
                }
            }
            // Test
            if (testRun)
            {
                Printf("TEST: Particles complete.\n");
                break;
            }
        }
        // Iterate
        for (blockIter = 0; blockIter < particleCount; blockIter++)
        {
            // Declare
            currentTrack                    = particleOffset + (blockIter * particleSize);
            particleEmissionSpeedOffset     = currentTrack + particleEmissionSpeedPadding;
            particleSpeedOffset             = currentTrack + particleSpeedPadding;
            particleVerticalOffset          = currentTrack + particleVerticalPadding;
            particleHorizontalOffset        = currentTrack + particleHorizontalPadding;
            particleGravityOffset           = currentTrack + particleGravityPadding;
            particleLifespanOffset          = currentTrack + particleLifespanPadding;
            particleEmissionRateOffset      = currentTrack + particleEmissionRatePadding;
            particleEmissionLengthOffset    = currentTrack + particleEmissionLengthPadding;
            particleEmissionWidthOffset     = currentTrack + particleEmissionWidthPadding;
            particleSourceOffset            = currentTrack + particleSourcePadding;
            particleColorOffset             = currentTrack + particleColorPadding;
            particleAlphaOffset             = currentTrack + particleAlphaPadding;
            particleScaleOffset             = currentTrack + particleScalePadding;
            particleEnabledOffset           = currentTrack + particleEnabledPadding;
            // Output
            if (!silent)
            {
                Printf("\nProcessing Particle: %u at 0x%X\n", blockIter, currentTrack);
            }
            // ---- EMISSION SPEED ----              
            trackInterpolation          =  ReadUShort(particleEmissionSpeedOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleEmissionSpeedOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleEmissionSpeedOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleEmissionSpeedOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleEmissionSpeedOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleEmissionSpeedOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleEmissionSpeedOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionSpeedOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleEmissionSpeedOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleEmissionSpeedOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleEmissionSpeedOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionSpeedOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[EMISSION SPEED] Particle[%u] @ 0x%X\n",        blockIter, particleEmissionSpeedOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Emission Speed Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleEmissionSpeed);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Emission Speed Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Emission Speed complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Emission Speed Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x * particleEmissionSpeed);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Emission Speed Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Emission Speed complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- SPEED ----              
            trackInterpolation          =  ReadUShort(particleSpeedOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleSpeedOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleSpeedOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleSpeedOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleSpeedOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleSpeedOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleSpeedOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleSpeedOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleSpeedOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleSpeedOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleSpeedOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleSpeedOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[SPEED] Particle[%u] @ 0x%X\n",                 blockIter, particleSpeedOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Speed Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleSpeed);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Speed Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Speed complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Speed Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x * particleSpeed);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Speed Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Speed complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- VERTICAL ----              
            trackInterpolation          =  ReadUShort(particleVerticalOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleVerticalOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleVerticalOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleVerticalOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleVerticalOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleVerticalOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleVerticalOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleVerticalOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleVerticalOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleVerticalOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleVerticalOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleVerticalOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Vertical] Particle[%u] @ 0x%X\n",              blockIter, particleVerticalOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Vertical Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleVertical);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Vertical Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Vertical complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Vertical Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x * particleVertical);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Vertical Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Vertical complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- HORIZONTAL ----              
            trackInterpolation          =  ReadUShort(particleHorizontalOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleHorizontalOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleHorizontalOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleHorizontalOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleHorizontalOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleHorizontalOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleHorizontalOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleHorizontalOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleHorizontalOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleHorizontalOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleHorizontalOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleHorizontalOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Horizontal] Particle[%u] @ 0x%X\n",            blockIter, particleHorizontalOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Horizontal Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleHorizontal);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Horizontal Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Horizontal complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Horizontal Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x * particleHorizontal);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Horizontal Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Horizontal complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- GRAVITY ----              
            trackInterpolation          =  ReadUShort(particleGravityOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleGravityOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleGravityOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleGravityOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleGravityOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleGravityOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleGravityOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleGravityOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleGravityOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleGravityOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleGravityOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleGravityOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Gravity] Particle[%u] @ 0x%X\n",               blockIter, particleGravityOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Gravity Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleGravity);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Gravity Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Gravity complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Gravity Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x * particleGravity);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Gravity Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Gravity complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- LIFESPAN ----              
            trackInterpolation          =  ReadUShort(particleLifespanOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleLifespanOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleLifespanOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleLifespanOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleLifespanOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleLifespanOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleLifespanOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleLifespanOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleLifespanOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleLifespanOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleLifespanOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleLifespanOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Lifespan] Particle[%u] @ 0x%X\n",               blockIter, particleLifespanOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Lifespan Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleLifespan);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Lifespan Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Lifespan complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Lifespan Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x * particleLifespan);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Lifespan Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Lifespan complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- EMISSION RATE ----              
            trackInterpolation          =  ReadUShort(particleEmissionRateOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleEmissionRateOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleEmissionRateOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleEmissionRateOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleEmissionRateOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleEmissionRateOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleEmissionRateOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionRateOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleEmissionRateOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleEmissionRateOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleEmissionRateOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionRateOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Emission Rate] Particle[%u] @ 0x%X\n",         blockIter, particleEmissionRateOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Emission Rate Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleEmissionRate);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Emission Rate Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Emission Rate complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Emission Rate Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x * particleEmissionRate);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Emission Rate Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Emission Rate complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- EMISSION LENGTH ----              
            trackInterpolation          =  ReadUShort(particleEmissionLengthOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleEmissionLengthOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleEmissionLengthOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleEmissionLengthOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleEmissionLengthOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleEmissionLengthOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleEmissionLengthOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionLengthOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleEmissionLengthOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleEmissionLengthOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleEmissionLengthOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionLengthOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Emission Length] Particle[%u] @ 0x%X\n",       blockIter, particleEmissionLengthOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Emission Length Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleEmissionLength);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Emission Length Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Emission Length complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Emission Length Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x * particleEmissionLength);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Emission Length Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Emission Length complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- EMISSION WIDTH ----              
            trackInterpolation          =  ReadUShort(particleEmissionWidthOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleEmissionWidthOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleEmissionWidthOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleEmissionWidthOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleEmissionWidthOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleEmissionWidthOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleEmissionWidthOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionWidthOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleEmissionWidthOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleEmissionWidthOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleEmissionWidthOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionWidthOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Emission Width] Particle[%u] @ 0x%X\n",       blockIter, particleEmissionWidthOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Emission Width Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleEmissionWidth);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Emission Width Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Emission Width complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Emission Width Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x * particleEmissionWidth);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Emission Width Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Emission Width complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- EMISSION LENGTH ----              
            trackInterpolation          =  ReadUShort(particleEmissionLengthOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleEmissionLengthOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleEmissionLengthOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleEmissionLengthOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleEmissionLengthOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleEmissionLengthOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleEmissionLengthOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionLengthOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleEmissionLengthOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleEmissionLengthOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleEmissionLengthOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionLengthOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Emission Length] Particle[%u] @ 0x%X\n",       blockIter, particleEmissionLengthOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Emission Length Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleEmissionLength);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Emission Length Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Emission Length complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Emission Length Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x * particleEmissionLength);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Emission Length Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Emission Length complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- EMISSION WIDTH ----              
            trackInterpolation          =  ReadUShort(particleEmissionWidthOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleEmissionWidthOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleEmissionWidthOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleEmissionWidthOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleEmissionWidthOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleEmissionWidthOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleEmissionWidthOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionWidthOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleEmissionWidthOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleEmissionWidthOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleEmissionWidthOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionWidthOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Emission Width] Particle[%u] @ 0x%X\n",       blockIter, particleEmissionWidthOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Emission Width Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleEmissionWidth);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Emission Width Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Emission Width complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Emission Width Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x * particleEmissionWidth);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Emission Width Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Emission Width complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- EMISSION LENGTH ----              
            trackInterpolation          =  ReadUShort(particleEmissionLengthOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleEmissionLengthOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleEmissionLengthOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleEmissionLengthOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleEmissionLengthOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleEmissionLengthOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleEmissionLengthOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionLengthOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleEmissionLengthOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleEmissionLengthOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleEmissionLengthOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleEmissionLengthOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Emission Length] Particle[%u] @ 0x%X\n",       blockIter, particleEmissionLengthOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Emission Length Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleEmissionLength);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Emission Length Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Emission Length complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Emission Length Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x * particleEmissionLength);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Emission Length Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Emission Length complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- SOURCE ----              
            trackInterpolation          =  ReadUShort(particleSourceOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleSourceOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleSourceOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleSourceOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleSourceOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleSourceOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleSourceOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleSourceOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleSourceOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleSourceOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleSourceOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleSourceOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Source] Particle[%u] @ 0x%X\n",        blockIter, particleSourceOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * floatSize;                        
                        // Read
                        x  = ReadFloat(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Source Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%.6f)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleSourceZ);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Source Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%.6f)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Source complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * floatSize);
                                // Read
                                x  = ReadFloat(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Source Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%.6f)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteFloat(pos, x * particleSourceZ);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Source Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%.6f)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Source complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
            // ---- COLOR ----
            // Wrath of the Lich King and higher
            if (expansion >= 3)
            {
                    trackTimestamps         =    ReadUInt(particleColorOffset + 0x00);
                    trackTimestampsOffset   =    ReadUInt(particleColorOffset + 0x04);
                    trackKeyPairs           =    ReadUInt(particleColorOffset + 0x08);
                    trackKeyPairsOffset     =    ReadUInt(particleColorOffset + 0x0C);
                // Output
                if (!silent)
                {
                    Printf("[Color] Particle[%u] @ 0x%X\n",                 blockIter, particleColorOffset);
                    Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
                }
                // Error
                if (trackTimestamps != trackKeyPairs)
                {
                    Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
                }
                // Catch
                if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
                {
                    // Iterate
                    for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * vectorSize;
                        // Read
                        x  = ReadFloat(pos + (floatSize * 0));
                        y  = ReadFloat(pos + (floatSize * 1));
                        z  = ReadFloat(pos + (floatSize * 2));
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Color Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                            Printf(" = (%.6f, %.6f, %.6f)\n", x, y, z);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleColorR);
                            WriteFloat(pos, y * particleColorG);
                            WriteFloat(pos, z * particleColorB);
                            // Output
                            if (debug)
                            {
                                Printf("    Particle[%u] New Color Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                Printf(" = (%.6f, %.6f, %.6f)\n", x. y, z);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Color complete.\n");
                            break;
                        }
                    }
                }
                // Output
                else if (!silent)
                {
                    Printf("  Empty value block.\n");
                }
            }
            // ---- ALPHA ----
            // Wrath of the Lich King and higher
            if (expansion >= 3)
            {
                    trackTimestamps         =    ReadUInt(particleAlphaOffset + 0x00);
                    trackTimestampsOffset   =    ReadUInt(particleAlphaOffset + 0x04);
                    trackKeyPairs           =    ReadUInt(particleAlphaOffset + 0x08);
                    trackKeyPairsOffset     =    ReadUInt(particleAlphaOffset + 0x0C);
                // Output
                if (!silent)
                {
                    Printf("[Alpha] Particle[%u] @ 0x%X\n",                 blockIter, particleAlphaOffset);
                    Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
                }
                // Error
                if (trackTimestamps != trackKeyPairs)
                {
                    Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
                }
                // Catch
                if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
                {
                    // Iterate
                    for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                    {
                        // Move
                        pos = subtrackOffset + (subIter * shortSize);
                        // Read
                        x  = ReadShort(pos + (shortSize * 0));
                        y  = ReadShort(pos + (shortSize * 1));
                        z  = ReadShort(pos + (shortSize * 2));
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Alpha Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                            Printf(" = (%u, %u, %u)\n", x, y, z);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteShort(pos, x * particleAlphaR);
                            WriteShort(pos, y * particleAlphaG);
                            WriteShort(pos, z * particleAlphaB);
                            // Output
                            if (debug)
                            {
                                Printf("    Particle[%u] New Alpha Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                Printf(" = (%u, %u, %u)\n", x. y, z);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Alpha complete.\n");
                            break;
                        }
                    }
                }
                // Output
                else if (!silent)
                {
                    Printf("  Empty value block.\n");
                }
            }
            // ---- SCALE ----
            // Wrath of the Lich King and higher
            if (expansion >= 3)
            {
                    trackTimestamps         =    ReadUInt(particleScaleOffset + 0x00);
                    trackTimestampsOffset   =    ReadUInt(particleScaleOffset + 0x04);
                    trackKeyPairs           =    ReadUInt(particleScaleOffset + 0x08);
                    trackKeyPairsOffset     =    ReadUInt(particleScaleOffset + 0x0C);
                // Output
                if (!silent)
                {
                    Printf("[Scale] Particle[%u] @ 0x%X\n",                 blockIter, particleScaleOffset);
                    Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
                }
                // Error
                if (trackTimestamps != trackKeyPairs)
                {
                    Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
                }
                // Catch
                if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
                {
                    // Iterate
                    for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                    {
                        // Move
                        pos = subtrackOffset + (subIter * quaternionSize);
                        // Read
                        x  = ReadFloat(pos + (floatSize * 0));
                        y  = ReadFloat(pos + (floatSize * 1));
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Scale Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                            Printf(" = (%u, %u)\n", x, y);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteFloat(pos, x * particleScaleX);
                            WriteFloat(pos, y * particleScaleY);
                            // Output
                            if (debug)
                            {
                                Printf("    Particle[%u] New Scale Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                Printf(" = (%u, %u)\n", x. y);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Scale complete.\n");
                            break;
                        }
                    }
                }
                // Output
                else if (!silent)
                {
                    Printf("  Empty value block.\n");
                }
            }
            // ---- ENABLED ----              
            trackInterpolation          =  ReadUShort(particleEnabledOffset + 0x00);
            trackGlobalSeq              =   ReadShort(particleEnabledOffset + 0x02);
            if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
            {
                trackRanges             =    ReadUInt(particleEnabledOffset + 0x04);
                trackRangesOffset       =    ReadUInt(particleEnabledOffset + 0x08);
                trackTimestamps         =    ReadUInt(particleEnabledOffset + 0x0C);
                trackTimestampsOffset   =    ReadUInt(particleEnabledOffset + 0x10);
                trackKeyPairs           =    ReadUInt(particleEnabledOffset + 0x14);
                trackKeyPairsOffset     =    ReadUInt(particleEnabledOffset + 0x18);
            }
            if (expansion >= 3) // Wrath of the Lich King and higher
            {
                trackTimestamps         =    ReadUInt(particleEnabledOffset + 0x04);
                trackTimestampsOffset   =    ReadUInt(particleEnabledOffset + 0x08);
                trackKeyPairs           =    ReadUInt(particleEnabledOffset + 0x0C);
                trackKeyPairsOffset     =    ReadUInt(particleEnabledOffset + 0x10);
            }
            // Output
            if (!silent)
            {
                Printf("[Enabled] Particle[%u] @ 0x%X\n",               blockIter, particleEnabledOffset);
                Printf("  Interpolation: %u\n",                         trackInterpolation);
                Printf("  Global Seq   : %d\n",                         trackGlobalSeq);
                if (expansion <= 2) // Alpha, Vanilla, The Burning Crusade
                {
                    Printf("  Interp Ranges: %u @ 0x%X\n",              trackRanges, trackRangesOffset);
                    Printf("  Timestamps   : %u @ 0x%X\n",              trackTimestamps, trackTimestampsOffset);
                }
                Printf("  Pairs        : %u @ 0x%X\n",                  trackKeyPairs, trackKeyPairsOffset);
            }
            // Error
            if (trackTimestamps != trackKeyPairs)
            {
                Printf("  WARNING: Timestamp Count (%u) does not match Key Frame Pairs (%u)!\n", trackTimestamps, trackKeyPairs);
            }
            // Catch
            if (trackKeyPairs > 0 && trackKeyPairsOffset > 0) 
            {
                // Iterate
                for (trackIter = 0; trackIter < trackKeyPairs; trackIter++)
                {
                    // Alpha, Vanilla, The Burning Crusade
                    if (expansion <= 2)
                    {
                        // Move
                        pos = trackKeyPairsOffset + trackIter * byteSize;                        
                        // Read
                        x  = ReadByte(pos);
                        // Output
                        if (debug) 
                        {
                            Printf("    Particle[%u] Current Enabled Value[%d] @ 0x%X", blockIter, trackIter, pos);
                            Printf(" = (%u)\n", x);
                        }
                        // Write
                        if (!readOnly)
                        {
                            // Write
                            WriteByte(pos, x * particleEnabledBool);
                            // Output
                            if (debug) 
                            {
                                Printf("    Particle[%u] New Enabled Value[%d] @ 0x%X", blockIter, trackIter, pos);
                                Printf(" = (%u)\n", x);
                            }
                        }
                        // Test
                        if (testRun)
                        {
                            Printf("TEST: Enabled complete.\n");
                            break;
                        }
                    }
                    // Wrath of the Lich King and higher
                    if (expansion >= 3)
                    {
                        // Move
                        pos = trackKeyPairsOffset + (trackIter * subtrackSize);
                        subtrackCount   = ReadUInt(pos + (intSize * 0));
                        subtrackOffset  = ReadUInt(pos + (intSize * 1));
                        // Catch
                        if (subtrackCount > 0 && subtrackOffset > 0)
                        {
                            // Iterate
                            for (subIter = 0; subIter < subtrackCount; subIter++)
                            {
                                // Move
                                pos = subtrackOffset + (subIter * byteSize);
                                // Read
                                x  = ReadByte(pos);
                                // Output
                                if (debug) 
                                {
                                    Printf("    Particle[%u] Current Enabled Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                    Printf(" = (%u)\n", x);
                                }
                                // Write
                                if (!readOnly)
                                {
                                    // Write
                                    WriteByte(pos, x * particleEnabledBool);
                                    // Output
                                    if (debug)
                                    {
                                        Printf("    Particle[%u] New Enabled Value[%d] Subtrack[%d] @ 0x%X", blockIter, trackIter, subIter, pos);
                                        Printf(" = (%u)\n", x);
                                    }
                                }
                                // Test
                                if (testRun)
                                {
                                    Printf("TEST: Enabled complete.\n");
                                    break;
                                }
                            }
                        }
                        // Output
                        else if (debug)
                        {
                            Printf("  Empty subtrack block.\n");
                        }
                    }
                }
            }
            // Output
            else if (!silent)
            {
                Printf("  Empty value block.\n");
            }
        }
    }
    // Error
    else
    {
        Printf("  No Particle Count(%d) or Particle Offset(%d).\n", particleCount, particleOffset);
    }
}
// ================================================================================================
///////////////////////////////////////////////////////////////////////////////////////////////////
//// FINISH ///////////////////////////////////////////////////////////////////////////////////////
// ==== OUTPUT ====================================================================================
if (sequenceEnabled || basicScaling)
{
    Printf("==== SEQUENCE ====\n");
    Printf("Sequence Modifier: (%.6f, %.6f, %.6f, %.6f)\n", sequencePositionX, sequencePositionY, sequencePositionZ, sequencePositionR);
}
if (boneEnabled || basicScaling)
{
    Printf("==== BONES ====\n");
    Printf("Translation Modifier: (%.6f, %.6f, %.6f)\n", boneTranslationPositionX, boneTranslationPositionY, boneTranslationPositionZ);
    if (!basicScaling)
    {
        Printf("Rotation Modifier: (%.6f, %.6f, %.6f, %.6f)\n", boneRotationPositionX, boneRotationPositionY, boneRotationPositionZ, boneRotationPositionW);
        Printf("Scale Modifier: (%.6f, %.6f, %.6f)\n", boneScalePositionX, boneScalePositionY, boneScalePositionZ);
    }
    Printf("Pivot Modifier: (%.6f, %.6f, %.6f)\n", bonePivotPositionX, bonePivotPositionY, bonePivotPositionZ);
}
if (verticeEnabled || basicScaling)
{
    Printf("==== VERTICE ====\n");
    Printf("Vertice Modifier: (%.6f, %.6f, %.6f)\n", verticePositionX, verticePositionY, verticePositionZ);
}
if (colorEnabled && !basicScaling)
{
    Printf("==== COLOR ====\n");
    Printf("Color Modifier: (%.6f, %.6f, %.6f, %.6f)\n", colorModifierR, colorModifierG, colorModifierB, colorModifierA);
}
if (weightEnabled && !basicScaling)
{
    Printf("==== WEIGHT ====\n");
    Printf("Weight Modifier: (%.6f)\n", weightModifierA);
}
if (transformEnabled && !basicScaling)
{
    Printf("==== TRANSFORM ====\n");
    Printf("Translation Modifier: (%.6f, %.6f, %.6f)\n", transformTranslationPositionX, transformTranslationPositionY, transformTranslationPositionZ);
    Printf("Rotation Modifier: (%.6f, %.6f, %.6f, %.6f)\n", transformRotationPositionX, transformRotationPositionY, transformRotationPositionZ, transformRotationPositionW);
    Printf("Scale Modifier: (%.6f, %.6f, %.6f)\n", transformScalePositionX, transformScalePositionY, transformScalePositionZ);
}
if (boundingEnabled || basicScaling)
{
    Printf("==== BOUNDING ====\n");
    Printf("Bounding Modifier: (%.6f, %.6f, %.6f, %.6f)\n", boundingPositionX, boundingPositionY, boundingPositionZ, boundingPositionR);
}
if (collisionEnabled || basicScaling)
{
    Printf("==== COLLISION ====\n");
    Printf("Collision Modifier: (%.6f, %.6f, %.6f, %.6f)\n", collisionPositionX, collisionPositionY, collisionPositionZ, collisionPositionR);
}
if (normalEnabled && !basicScaling)
{
    Printf("==== NORMAL ====\n");
    Printf("Normal Modifier: (%.6f, %.6f, %.6f)\n", normalPositionX, normalPositionY, normalPositionZ);
}
if (attachmentEnabled || basicScaling)
{
    Printf("==== ATTACHMENT ====\n");
    Printf("Attachment Modifier: (%.6f, %.6f, %.6f)\n", attachmentPositionX, attachmentPositionY, attachmentPositionZ);
}
if (eventEnabled || basicScaling)
{
    Printf("==== EVENT ====\n");
    Printf("Event Modifier: (%.6f, %.6f, %.6f)\n", eventPositionX, eventPositionY, eventPositionZ);
}
if (lightEnabled || basicScaling)
{
    Printf("==== LIGHT ====\n");
    Printf("Light Modifier: (%.6f, %.6f, %.6f)\n", lightPositionX, lightPositionY, lightPositionZ);
}
if (cameraEnabled && !basicScaling)
{
    Printf("==== CAMERA ====\n");
    Printf("Camera Modifier: (%.6f, %.6f, %.6f)\n", cameraPositionX, cameraPositionY, cameraPositionZ);
}
if (ribbonEnabled || basicScaling)
{
    Printf("==== RIBBON ====\n");
    Printf("Ribbon Modifier: (%.6f, %.6f, %.6f)\n", ribbonPositionX, ribbonPositionY, ribbonPositionZ);
}
if (particleEnabled || basicScaling)
{
    Printf("==== PARTICLE ====\n");
    Printf("Particle Modifier: (%.6f, %.6f, %.6f)\n", particlePositionX, particlePositionY, particlePositionZ);
}
Printf("\n==== Resize Finished! ====\n");
// ==== SAVE ======================================================================================
if (autoSave)
{
    FileSave();
    Printf("  File saved!\n");
}
// ==== CLOSE =====================================================================================
if (autoClose)
{
    FileClose();
    Printf("  File closed!\n");
}